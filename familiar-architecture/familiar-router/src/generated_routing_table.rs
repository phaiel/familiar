// ⚠️ **PARTIALLY GENERATED** routing table
// This extracts SOME CEL expressions from schemas but does NOT generate
// actual routing algorithms. True schema-driven routing would generate
// complete decision logic, not just pre-compiled expressions.
//
// What this does: Extract and pre-compile individual CEL strings
// What it should do: Generate complete routing state machines from schema hierarchies
//
// Generated by xtask from schema CEL expressions

use std::collections::HashMap;
use cel_interpreter::Program;

#[derive(Debug)]
pub struct RoutingTable {
    pub node_constraints: HashMap<String, Vec<Program>>,
    pub routing_policies: HashMap<String, Vec<Program>>,
    pub timeout_constraints: HashMap<String, Program>,
}

impl RoutingTable {
    pub fn load() -> Result<Self> {
        let node_constraints = HashMap::new();
        let mut routing_policies = HashMap::new();
        let mut timeout_constraints = HashMap::new();

        // Classification System - routing_policy
        routing_policies.entry("Classification System".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("input.urgency == 'high' ? 'gpu-pool' : 'cpu-pool'")?);

        // Classification System - timeout_constraint
        timeout_constraints.insert("Classification System".to_string(), Program::compile("config:systems.classifier_system.timeouts.classification")?);

        // Classification System - routing_policy
        routing_policies.entry("Classification System".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("'cpu-pool'")?);

        // Classification System - timeout_constraint
        timeout_constraints.insert("Classification System".to_string(), Program::compile("config:systems.classifier_system.timeouts.entity_segment")?);

        // Classification System - routing_policy
        routing_policies.entry("Classification System".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("'cpu-pool'")?);

        // Classification System - timeout_constraint
        timeout_constraints.insert("Classification System".to_string(), Program::compile("config:systems.classifier_system.timeouts.purpose_classification")?);

        // CoreRouter - routing_policy
        routing_policies.entry("CoreRouter".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("true")?);

        // CoreRouter - timeout_constraint
        timeout_constraints.insert("CoreRouter".to_string(), Program::compile("config:routing.decision_timeout_ms")?);

        // Fates Gate - routing_policy
        routing_policies.entry("Fates Gate".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("input.content_length > 10000 ? 'high-memory-pool' : 'standard-pool'")?);

        // Fates Gate - timeout_constraint
        timeout_constraints.insert("Fates Gate".to_string(), Program::compile("config:systems.fates_gate.timeouts.weave")?);

        // Fates Gate - routing_policy
        routing_policies.entry("Fates Gate".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("input.complexity > 0.8 ? 'gpu-pool' : 'cpu-pool'")?);

        // Fates Gate - timeout_constraint
        timeout_constraints.insert("Fates Gate".to_string(), Program::compile("config:systems.fates_gate.timeouts.search")?);

        // Fates Gate - routing_policy
        routing_policies.entry("Fates Gate".to_string())
            .or_insert_with(Vec::new)
            .push(Program::compile("'ml-pool'")?);

        // Fates Gate - timeout_constraint
        timeout_constraints.insert("Fates Gate".to_string(), Program::compile("config:systems.fates_gate.timeouts.classify")?);

        Ok(RoutingTable {
            node_constraints,
            routing_policies,
            timeout_constraints,
        })
    }
}
