//! Generated from JSON schemas - DO NOT EDIT
//!
//! This file is generated by `cargo xtask codegen generate`.
//! To regenerate, run that command from the workspace root.
//!
//! Stats: 33 primitives (skipped), 433 generated, 1 disambiguated

use serde::{Deserialize, Serialize};
use schemars::JsonSchema;

// Primitives from familiar_primitives (auto-detected from primitives/ directory)
#[allow(unused_imports)]
use super::{
    ApiKey, AuditLogId, ChannelId, ConsentRecordId, CourseId, DbConnectionString,
    DbPoolSize, DeletionRequestId, Email, EntityId, ExportRequestId, InvitationId,
    InviteCode, InviteRole, JoinRequestId, MagicLinkId, MaxTokens, MessageId,
    NormalizedFloat, PasswordHash, QuantizedCoord, SessionId, SessionToken, ShuttleId,
    SignedNormalizedFloat, TaskId, Temperature, TenantId, ThreadId, Timestamp,
    TokenUsage, UUID, UserId,
    // Re-exported from dependencies
    DateTime, Utc, Uuid,
};

/// MagicLinkAction
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MagicLinkAction {
    #[serde(rename = "request")]
    Request,
    #[serde(rename = "consume")]
    Consume,
}

/// OnboardingSession
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OnboardingSession {
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<serde_json::Value>,
    pub expires_at: Timestamp,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub join_request_id: Option<serde_json::Value>,
    pub metadata: serde_json::Value,
    pub session_key: String,
    pub state: OnboardingState,
    pub steps_completed: Vec<String>,
    pub updated_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<UserId>,
}

/// GateOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct GateOutput {
    pub classification: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_fate: Option<String>,
    pub shuttle_id: UUID,
}

/// FamiliarWorkerNode
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FamiliarWorkerNode(pub serde_json::Value);

/// DatabasepoolComponent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DatabasepoolComponent {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_connections: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min_connections: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pool: Option<serde_json::Value>,
}

impl Default for DatabasepoolComponent {
    fn default() -> Self {
        Self {
            max_connections: 20,
            min_connections: 5,
            pool: serde_json::Value::Null,
        }
    }
}

/// DbPoolConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DbPoolConfig {
    pub connect_timeout_secs: i64,
    pub connection: DbConnectionString,
    pub idle_timeout_secs: i64,
    pub max_connections: DbPoolSize,
    pub min_connections: DbPoolSize,
}

/// FamiliarDaemonNode
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FamiliarDaemonNode(pub serde_json::Value);

/// TigerdatastoreComponent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TigerdatastoreComponent {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pool: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_enforcer: Option<serde_json::Value>,
}

/// PostgresTigerResource
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PostgresTigerResource(pub serde_json::Value);

/// ContractenforcerComponent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContractenforcerComponent {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compiled_schemas: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// FatesgateSystem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FatesgateSystem(pub serde_json::Value);

/// GateInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct GateInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<Box<RequestContext>>,
    pub message: PlainTextObject,
    pub thread_id: UUID,
}

/// RequestContext
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RequestContext {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
}

/// Moment
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Moment {
    pub amplitudes: Vec<(f64, f64)>,
    pub coherence: NormalizedFloat,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
    pub id: UUID,
    pub metadata: serde_json::Value,
    pub moment_type: MomentType,
    pub physics: Box<FieldExcitation>,
    pub tenant_id: TenantId,
    pub text: String,
}

/// FieldExcitation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FieldExcitation {
    pub amplitude: NormalizedFloat,
    pub energy: NormalizedFloat,
    pub position: [QuantizedCoord; 3],
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position_workspace: Option<[f64; 3]>,
    pub temperature: NormalizedFloat,
    pub velocity: [QuantizedCoord; 3],
    #[serde(skip_serializing_if = "Option::is_none")]
    pub velocity_workspace: Option<[f64; 3]>,
}

/// Thread
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Thread {
    pub amplitudes: Vec<(f64, f64)>,
    pub coherence: NormalizedFloat,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
    pub id: ThreadId,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    pub tenant_id: TenantId,
    pub text: String,
    pub thread_type: ThreadType,
}

/// Course
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Course {
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub history: Option<Vec<CourseMessage>>,
    pub id: CourseId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<CourseMetadata>,
    pub status: CourseStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<serde_json::Value>,
    pub tenant_id: TenantId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<serde_json::Value>,
    pub updated_at: Timestamp,
}

impl Default for Course {
    fn default() -> Self {
        Self {
            created_at: ../primitives/Timestamp.schema.json::default(),
            history: vec![],
            id: ../primitives/CourseId.schema.json::default(),
            metadata: CourseMetadata.schema.json::default(),
            status: ../types/CourseStatus.schema.json::default(),
            summary: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            title: Default::default(),
            updated_at: ../primitives/Timestamp.schema.json::default(),
        }
    }
}

/// Shuttle
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Shuttle {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<Timestamp>,
    pub course_id: CourseId,
    pub created_at: Timestamp,
    pub details: ShuttleDetails,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<serde_json::Value>,
    pub id: ShuttleId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<Timestamp>,
    pub status: ShuttleStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub units: Option<Vec<WeaveUnit>>,
    pub weave: Weave,
}

impl Default for Shuttle {
    fn default() -> Self {
        Self {
            completed_at: ../primitives/Timestamp.schema.json::default(),
            course_id: ../primitives/CourseId.schema.json::default(),
            created_at: ../primitives/Timestamp.schema.json::default(),
            details: ShuttleDetails.schema.json::default(),
            error: Default::default(),
            id: ../primitives/ShuttleId.schema.json::default(),
            response: Default::default(),
            started_at: ../primitives/Timestamp.schema.json::default(),
            status: ../types/ShuttleStatus.schema.json::default(),
            units: vec![],
            weave: ../components/Weave.schema.json::default(),
        }
    }
}

/// WeaveUnit
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WeaveUnit {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<WeaveUnitClassification>>,
    pub content: String,
    pub index: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_thread: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purpose: Option<MessageIntent>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_threads: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spawned_entity_ids: Option<Vec<UUID>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal_marker: Option<serde_json::Value>,
}

impl Default for WeaveUnit {
    fn default() -> Self {
        Self {
            classifications: vec![],
            content: "".to_string(),
            index: 0,
            primary_thread: Default::default(),
            purpose: "LOG".to_string(),
            secondary_threads: vec![],
            spawned_entity_ids: vec![],
            temporal_marker: Default::default(),
        }
    }
}

/// WeaveUnitClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WeaveUnitClassification {
    pub entity_type: HeddleEntityType,
    pub weight: NormalizedFloat,
}

/// Weave
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Weave {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<serde_json::Value>,
    pub raw_content: String,
}

/// FatesmortaSystem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FatesmortaSystem(pub serde_json::Value);

/// Pulse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Pulse {
    pub created_at: Timestamp,
    pub id: UUID,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    pub state_type: InternalStateType,
    pub tenant_id: TenantId,
    pub text: String,
}

/// FatesdecimaSystem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FatesdecimaSystem(pub serde_json::Value);

/// Bond
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Bond {
    pub bond_strength: NormalizedFloat,
    pub created_at: Timestamp,
    pub damping_coefficient: f64,
    pub formalism: NormalizedFloat,
    pub head_thread_id: UUID,
    pub id: UUID,
    pub intimacy: NormalizedFloat,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    pub power_dynamic: SignedNormalizedFloat,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_label: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spectral_signature: Option<serde_json::Value>,
    pub spring_constant: f64,
    pub tail_thread_id: UUID,
    pub tenant_id: TenantId,
    pub text: String,
    pub transparency: NormalizedFloat,
}

/// FatesnonaSystem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FatesnonaSystem(pub serde_json::Value);

/// Filament
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Filament {
    pub amplitudes: Vec<(f64, f64)>,
    pub coherence: NormalizedFloat,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
    pub id: UUID,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    pub source_pulses: Vec<UUID>,
    pub tenant_id: TenantId,
    pub text: String,
}

/// PostgresMainResource
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PostgresMainResource(pub serde_json::Value);

/// VAEPosition
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct VAEPosition {
    pub x: i64,
    pub y: i64,
    pub z: i64,
}

/// CreateMagicLinkInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateMagicLinkInput {
    pub email: Email,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_in_minutes: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub purpose: MagicLinkPurpose,
}

impl Default for CreateMagicLinkInput {
    fn default() -> Self {
        Self {
            email: ../primitives/Email.schema.json::default(),
            expires_in_minutes: 15,
            metadata: Default::default(),
            purpose: MagicLinkPurpose.schema.json::default(),
        }
    }
}

/// MessageClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MessageClassification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f64>,
    pub intent: MessageIntent,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_target: Option<QueryTarget>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response_metadata: Option<ResponseMetadata>,
}

/// EntityMentionType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum EntityMentionType {
    #[serde(rename = "PERSON")]
    Person,
    #[serde(rename = "PLACE")]
    Place,
    #[serde(rename = "ORGANIZATION")]
    Organization,
    #[serde(rename = "DATE_TIME")]
    DateTime,
    #[serde(rename = "EVENT")]
    Event,
    #[serde(rename = "CONCEPT")]
    Concept,
    #[serde(rename = "OBJECT")]
    Object,
    #[serde(rename = "ACTIVITY")]
    Activity,
}

/// WebpageBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WebpageBlock {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_images: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selector: Option<serde_json::Value>,
    pub url: String,
}

impl Default for WebpageBlock {
    fn default() -> Self {
        Self {
            extract_images: false,
            selector: Default::default(),
            url: "".to_string(),
        }
    }
}

/// TenantMember
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TenantMember {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<serde_json::Value>,
    pub id: TenantId,
    pub name: String,
    pub role: MemberRole,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings: Option<serde_json::Value>,
    pub tenant_id: TenantId,
    pub updated_at: String,
}

impl Default for TenantMember {
    fn default() -> Self {
        Self {
            avatar_url: Default::default(),
            created_at: "".to_string(),
            email: Default::default(),
            id: ../primitives/TenantId.schema.json::default(),
            name: "".to_string(),
            role: ../types/MemberRole.schema.json::default(),
            settings: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            updated_at: "".to_string(),
        }
    }
}

/// AnthropicMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AnthropicMessage {
    pub content: String,
    pub role: String,
}

/// OpenaiGpt4Resource
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OpenaiGpt4Resource(pub serde_json::Value);

/// SpawnSummary
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SpawnSummary {
    pub auto_spawn_count: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_type: Option<EntityType>,
    pub review_count: i64,
    pub skipped_count: i64,
    pub total_suggestions: i64,
}

impl Default for SpawnSummary {
    fn default() -> Self {
        Self {
            auto_spawn_count: 0,
            primary_type: ../primitives/EntityType.schema.json::default(),
            review_count: 0,
            skipped_count: 0,
            total_suggestions: 0,
        }
    }
}

/// SpawnSuggestion
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SpawnSuggestion {
    pub action: SpawnAction,
    pub confidence: f64,
    pub content: EntityContent,
    pub entity_type: EntityType,
    pub hints: SpawnHints,
    pub reason: String,
}

/// InteractionFrequency
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum InteractionFrequency {
    #[serde(rename = "daily")]
    Daily,
    #[serde(rename = "weekly")]
    Weekly,
    #[serde(rename = "monthly")]
    Monthly,
    #[serde(rename = "quarterly")]
    Quarterly,
    #[serde(rename = "yearly")]
    Yearly,
    #[serde(rename = "rarely")]
    Rarely,
}

/// EntityMention
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityMention {
    pub confidence: f64,
    pub end: i64,
    pub entity_type: EntityMentionType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved_id: Option<serde_json::Value>,
    pub start: i64,
    pub text: String,
}

impl Default for EntityMention {
    fn default() -> Self {
        Self {
            confidence: 0.0,
            end: 0,
            entity_type: #/definitions/EntityMentionType::default(),
            resolved_id: Default::default(),
            start: 0,
            text: "".to_string(),
        }
    }
}

/// OptionObject
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OptionObject {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<PlainTextObject>,
    pub text: PlainTextObject,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<serde_json::Value>,
    pub value: String,
}

/// ContentClassificationResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContentClassificationResponse {
    pub classifications: Vec<SegmentClassification>,
    pub request_id: String,
}

/// ModelInfo
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ModelInfo {
    pub api_model_id: String,
    pub id: String,
    pub name: String,
    pub provider: String,
}

/// PhysicsHintOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsHintOutput {
    pub analysis: PhysicsAnalysis,
    pub hints: PhysicsHintValues,
    pub position: VAEPosition,
}

/// ToolChain
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolChain {
    pub context_strategy: ContextStrategy,
    pub description: String,
    pub error_strategy: ErrorStrategy,
    pub id: String,
    pub name: String,
    pub steps: Vec<ToolChainStep>,
}

/// EntityClassificationContext
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityClassificationContext {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub following: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub known_threads: Option<Vec<ThreadReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preceding: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_patterns: Option<EntityPatterns>,
}

impl Default for EntityClassificationContext {
    fn default() -> Self {
        Self {
            following: Default::default(),
            known_threads: vec![],
            preceding: Default::default(),
            user_patterns: EntityPatterns.schema.json::default(),
        }
    }
}

/// WeaveRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WeaveRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_key: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blocks: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context_blocks: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub threshold: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weave: Option<serde_json::Value>,
}

/// TenantMemberModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TenantMemberModel {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Email>,
    pub id: ThreadId,
    pub name: String,
    pub role: MemberRole,
    pub settings: serde_json::Value,
    pub tenant_id: TenantId,
    pub updated_at: String,
    pub user_id: UserId,
}

/// ClassificationResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassificationResponse {
    pub entity_type: String,
    pub weight: f64,
}

/// Tenant
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Tenant {
    pub created_at: String,
    pub id: TenantId,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings: Option<serde_json::Value>,
    pub updated_at: String,
}

impl Default for Tenant {
    fn default() -> Self {
        Self {
            created_at: "".to_string(),
            id: ../primitives/TenantId.schema.json::default(),
            name: "".to_string(),
            settings: Default::default(),
            updated_at: "".to_string(),
        }
    }
}

/// Identity
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Identity {
    pub created_at: Timestamp,
    pub id: UUID,
    pub tenant_id: TenantId,
}

/// FamilyInvitation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FamilyInvitation {
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Email>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<serde_json::Value>,
    pub id: InvitationId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<InviteCode>,
    pub invite_type: InviteType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invited_by: Option<serde_json::Value>,
    pub max_uses: i64,
    pub role: InviteRole,
    pub tenant_id: TenantId,
    pub use_count: i64,
}

impl Default for FamilyInvitation {
    fn default() -> Self {
        Self {
            created_at: "".to_string(),
            email: ../primitives/Email.schema.json::default(),
            expires_at: Default::default(),
            id: ../primitives/InvitationId.schema.json::default(),
            invite_code: ../primitives/InviteCode.schema.json::default(),
            invite_type: InviteType.schema.json::default(),
            invited_by: Default::default(),
            max_uses: 0,
            role: ../primitives/InviteRole.schema.json::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            use_count: 0,
        }
    }
}

/// UpdateUserInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UpdateUserInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_tenant_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings: Option<serde_json::Value>,
}

impl Default for UpdateUserInput {
    fn default() -> Self {
        Self {
            avatar_url: Default::default(),
            name: Default::default(),
            primary_tenant_id: Default::default(),
            settings: Default::default(),
        }
    }
}

/// PhysicsState
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsState {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub energy: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mass: Option<f64>,
    pub position: VAEPosition,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub velocity: Option<VAEPosition>,
}

impl Default for PhysicsState {
    fn default() -> Self {
        Self {
            energy: 0.5,
            mass: 0.5,
            position: ../tools/VAEPosition.schema.json::default(),
            temperature: 0.5,
            velocity: ../tools/VAEPosition.schema.json::default(),
        }
    }
}

/// FamilyInvitationModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FamilyInvitationModel {
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Email>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<serde_json::Value>,
    pub id: InvitationId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<InviteCode>,
    pub invite_type: InviteType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invited_by: Option<UserId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_uses: Option<serde_json::Value>,
    pub role: InviteRole,
    pub tenant_id: TenantId,
    pub use_count: i64,
}

/// SignupConsents
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SignupConsents {
    pub privacy: bool,
    pub terms: bool,
}

/// Finding
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Finding {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<serde_json::Value>,
    pub description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub related_entities: Option<Vec<String>>,
    pub title: String,
}

impl Default for Finding {
    fn default() -> Self {
        Self {
            confidence: Default::default(),
            description: "".to_string(),
            related_entities: vec![],
            title: "".to_string(),
        }
    }
}

/// SystemEntityMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SystemEntityMeta {
    pub created_at: Timestamp,
    pub id: serde_json::Value,
    pub updated_at: Timestamp,
}

/// Intent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Intent {
    pub activation_energy: NormalizedFloat,
    pub completion: NormalizedFloat,
    pub created_at: Timestamp,
    pub entropy: NormalizedFloat,
    pub id: UUID,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_status_label: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_date: Option<Timestamp>,
    pub tenant_id: TenantId,
    pub text: String,
}

/// JoinRequestModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct JoinRequestModel {
    pub created_at: String,
    pub id: JoinRequestId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub review_note: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_at: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_by: Option<UserId>,
    pub status: JoinRequestStatus,
    pub tenant_id: TenantId,
    pub user_id: UserId,
}

/// InputBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct InputBlock {
    pub element: BlockElement,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hint: Option<PlainTextObject>,
    pub label: PlainTextObject,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

impl Default for InputBlock {
    fn default() -> Self {
        Self {
            element: ../primitives/BlockElement.schema.json::default(),
            hint: ../primitives/PlainTextObject.schema.json::default(),
            label: ../primitives/PlainTextObject.schema.json::default(),
            optional: false,
        }
    }
}

/// ToolError
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolError {
    pub code: ToolErrorCode,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,
    pub message: String,
    pub retryable: bool,
}

/// AcceptInvitationFlowInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AcceptInvitationFlowInput {
    pub invite_code: String,
    pub request_id: String,
    pub user_id: UserId,
}

/// ToolErrorCode
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ToolErrorCode {
    INVALID_INPUT,
    MISSING_PARAMETER,
    VALIDATION_FAILED,
    TIMEOUT,
    RATE_LIMITED,
    SERVICE_UNAVAILABLE,
    LLM_ERROR,
    INTERNAL_ERROR,
    NOT_FOUND,
    PERMISSION_DENIED,
}

/// ObserverError
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum ObserverError {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
    Variant6,
}

/// ResourceMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ResourceMeta {
    #[serde(rename = "$schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_schema: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub title: String,
    #[serde(rename = "x-familiar-config")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_config: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-connection-pool")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_connection_pool: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-endpoint")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_endpoint: Option<String>,
    #[serde(rename = "x-familiar-health-check")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_health_check: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-kind")]
    pub x_familiar_kind: String,
    #[serde(rename = "x-familiar-models")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_models: Option<Vec<String>>,
    #[serde(rename = "x-familiar-rate-limit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rate_limit: Option<i64>,
    #[serde(rename = "x-familiar-resource-type")]
    pub x_familiar_resource_type: String,
    #[serde(rename = "x-familiar-tables")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_tables: Option<Vec<String>>,
    #[serde(rename = "x-familiar-virtual")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_virtual: Option<bool>,
}

impl Default for ResourceMeta {
    fn default() -> Self {
        Self {
            schema_schema: "".to_string(),
            description: "".to_string(),
            title: "".to_string(),
            x_familiar_config: serde_json::Value::Null,
            x_familiar_connection_pool: serde_json::Value::Null,
            x_familiar_endpoint: "".to_string(),
            x_familiar_health_check: serde_json::Value::Null,
            x_familiar_kind: "".to_string(),
            x_familiar_models: vec![],
            x_familiar_rate_limit: 0,
            x_familiar_resource_type: "".to_string(),
            x_familiar_tables: vec![],
            x_familiar_virtual: false,
        }
    }
}

/// TimeUnit
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TimeUnit {
    #[serde(rename = "seconds")]
    Seconds,
    #[serde(rename = "minutes")]
    Minutes,
    #[serde(rename = "hours")]
    Hours,
    #[serde(rename = "days")]
    Days,
    #[serde(rename = "weeks")]
    Weeks,
    #[serde(rename = "months")]
    Months,
    #[serde(rename = "years")]
    Years,
}

/// Conversation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Conversation {
    pub messages: Vec<ChatMessage>,
}

/// EntityClassifierOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityClassifierOutput {
    pub classifications: Vec<EntityClassification>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enriched_content: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_thread: Option<ThreadReference>,
    pub reasoning: ClassificationReasoning,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_threads: Option<Vec<ThreadReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal_marker: Option<serde_json::Value>,
}

impl Default for EntityClassifierOutput {
    fn default() -> Self {
        Self {
            classifications: vec![],
            enriched_content: Default::default(),
            primary_thread: ../primitives/ThreadReference.schema.json::default(),
            reasoning: ClassificationReasoning.schema.json::default(),
            secondary_threads: vec![],
            temporal_marker: Default::default(),
        }
    }
}

/// SessionCreated
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SessionCreated {
    pub expires_at: String,
    pub session_id: SessionId,
    pub token: SessionToken,
}

/// TemporalMarker
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TemporalMarker {
    pub marker_type: TemporalMarkerType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parsed: Option<ParsedTemporal>,
    pub text: String,
}

impl Default for TemporalMarker {
    fn default() -> Self {
        Self {
            marker_type: #/definitions/TemporalMarkerType::default(),
            parsed: #/definitions/ParsedTemporal::default(),
            text: "".to_string(),
        }
    }
}

/// HeddleResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct HeddleResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_intent: Option<RawMessageIntent>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weave_units: Option<Vec<RawWeaveUnit>>,
}

impl Default for HeddleResponse {
    fn default() -> Self {
        Self {
            message_intent: RawMessageIntent.schema.json::default(),
            weave_units: vec![],
        }
    }
}

/// RawWeaveUnit
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RawWeaveUnit {
    pub classifications: Vec<RawClassification>,
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
}

/// ContextBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContextBlock {
    pub elements: Vec<ContextElement>,
}

/// MessageIntentResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MessageIntentResponse {
    pub confidence: f64,
    pub intent: MessageIntent,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_target: Option<QueryTarget>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_type: Option<QueryType>,
}

/// SchemaInfo
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SchemaInfo {
    pub format: String,
    pub subject: String,
    pub version: i64,
}

/// Metadata
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Metadata(pub serde_json::Value);

/// CourseMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CourseMessage {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_speaker: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<serde_json::Value>,
    pub course_id: UUID,
    pub id: UUID,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub role: MessageRole,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shuttle_id: Option<UUID>,
    pub timestamp: Timestamp,
}

impl Default for CourseMessage {
    fn default() -> Self {
        Self {
            agent_speaker: Default::default(),
            content: Default::default(),
            course_id: ../primitives/UUID.schema.json::default(),
            id: ../primitives/UUID.schema.json::default(),
            metadata: Default::default(),
            role: ../primitives/MessageRole.schema.json::default(),
            shuttle_id: ../primitives/UUID.schema.json::default(),
            timestamp: ../primitives/Timestamp.schema.json::default(),
        }
    }
}

/// ClassifierOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassifierOutput {
    pub classifications: Vec<ClassificationResult>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub done: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics_hint: Option<PhysicsHint>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_thread: Option<serde_json::Value>,
    pub response_message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_threads: Option<Vec<String>>,
    pub state: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal_marker: Option<serde_json::Value>,
    pub text: String,
}

impl Default for ClassifierOutput {
    fn default() -> Self {
        Self {
            classifications: vec![],
            done: true,
            physics_hint: ../components/PhysicsHint.schema.json::default(),
            primary_thread: Default::default(),
            response_message: "".to_string(),
            secondary_threads: vec![],
            state: Default::default(),
            temporal_marker: Default::default(),
            text: "".to_string(),
        }
    }
}

/// MessageIntent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MessageIntent {
    LOG,
    QUERY,
    INFER,
    REFERENCE,
    REFLECT,
    COMMAND,
    SOCIAL,
}

/// CreateEntityInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateEntityInput {
    pub content: String,
    pub entity_type: FamiliarEntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics: Option<EntityPhysics>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_channel_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_message_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<EntityStatus>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
    pub tenant_id: TenantId,
}

impl Default for CreateEntityInput {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            entity_type: ../entities/FamiliarEntityType.schema.json::default(),
            metadata: Default::default(),
            physics: EntityPhysics.schema.json::default(),
            source_channel_id: Default::default(),
            source_message_id: Default::default(),
            status: ../entities/EntityStatus.schema.json::default(),
            subject: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
        }
    }
}

/// ImageElement
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ImageElement {
    pub alt_text: String,
    pub image_url: String,
}

/// DetectedAction
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedAction {
    pub action: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actor: Option<serde_json::Value>,
    pub confidence: f64,
}

impl Default for DetectedAction {
    fn default() -> Self {
        Self {
            action: "".to_string(),
            actor: Default::default(),
            confidence: 0.0,
        }
    }
}

/// EntityMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityMeta {
    pub created_at: Timestamp,
    pub id: serde_json::Value,
    pub tenant_id: TenantId,
    pub updated_at: Timestamp,
}

/// SpawnConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SpawnConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_spawn_enabled: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub high_confidence_threshold: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub low_confidence_threshold: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub manual_only_types: Option<Vec<EntityType>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_entities_per_segment: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub medium_confidence_threshold: Option<f64>,
}

impl Default for SpawnConfig {
    fn default() -> Self {
        Self {
            auto_spawn_enabled: true,
            high_confidence_threshold: 0.8,
            low_confidence_threshold: 0.3,
            manual_only_types: vec![],
            max_entities_per_segment: 3,
            medium_confidence_threshold: 0.5,
        }
    }
}

/// ClassificationSuperposition
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassificationSuperposition {
    pub classifications: Vec<WeightedClassification>,
}

/// PhysicsHintResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsHintResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arousal: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub clarity: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intrusiveness: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub significance: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valence: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub volatility: Option<serde_json::Value>,
}

/// ModalityInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "modality")]
pub enum ModalityInput {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
}

/// EvidenceType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum EvidenceType {
    verb_type,
    keywords,
    temporal,
    emotional,
    entity_mention,
    relational,
    pattern,
    context,
}

/// ParsedTemporal
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ParsedTemporal {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub date: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relative_days: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_of_day: Option<serde_json::Value>,
}

impl Default for ParsedTemporal {
    fn default() -> Self {
        Self {
            date: Default::default(),
            relative_days: Default::default(),
            time_of_day: Default::default(),
        }
    }
}

/// AuditLogEntry
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AuditLogEntry {
    pub action: String,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<serde_json::Value>,
    pub id: AuditLogId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_type: Option<serde_json::Value>,
    pub success: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_email: Option<Email>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<serde_json::Value>,
}

impl Default for AuditLogEntry {
    fn default() -> Self {
        Self {
            action: "".to_string(),
            created_at: "".to_string(),
            error_message: Default::default(),
            id: ../primitives/AuditLogId.schema.json::default(),
            ip_address: Default::default(),
            metadata: Default::default(),
            resource_id: Default::default(),
            resource_type: Default::default(),
            success: false,
            user_agent: Default::default(),
            user_email: ../primitives/Email.schema.json::default(),
            user_id: Default::default(),
        }
    }
}

/// EnumRepr
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum EnumRepr {
    #[serde(rename = "internally_tagged")]
    InternallyTagged,
    #[serde(rename = "adjacently_tagged")]
    AdjacentlyTagged,
    #[serde(rename = "externally_tagged")]
    ExternallyTagged,
    #[serde(rename = "untagged")]
    Untagged,
}

/// BindingCharacteristics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingCharacteristics {
    pub binding_type: BindingType,
    pub directionality: Directionality,
    pub salience: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub semantic: Option<SemanticProperties>,
    pub strength: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal: Option<TemporalProperties>,
}

impl Default for BindingCharacteristics {
    fn default() -> Self {
        Self {
            binding_type: ../primitives/BindingType.schema.json::default(),
            directionality: ../primitives/Directionality.schema.json::default(),
            salience: 0.0,
            semantic: SemanticProperties.schema.json::default(),
            strength: 0.0,
            temporal: TemporalProperties.schema.json::default(),
        }
    }
}

/// UserModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UserModel {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deletion_requested_at: Option<serde_json::Value>,
    pub email: Email,
    pub email_verified: bool,
    pub gdpr_consents: serde_json::Value,
    pub id: UserId,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password_hash: Option<PasswordHash>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_tenant_id: Option<TenantId>,
    pub settings: serde_json::Value,
    pub updated_at: String,
}

/// TemporalBinding
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TemporalBinding {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gap: Option<serde_json::Value>,
    pub relation: TemporalRelation,
}

impl Default for TemporalBinding {
    fn default() -> Self {
        Self {
            gap: Default::default(),
            relation: ../primitives/TemporalRelation.schema.json::default(),
        }
    }
}

/// MagicLink
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLink {
    pub created_at: String,
    pub email: Email,
    pub expires_at: String,
    pub id: MagicLinkId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub purpose: MagicLinkPurpose,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub used_at: Option<serde_json::Value>,
}

impl Default for MagicLink {
    fn default() -> Self {
        Self {
            created_at: "".to_string(),
            email: ../primitives/Email.schema.json::default(),
            expires_at: "".to_string(),
            id: ../primitives/MagicLinkId.schema.json::default(),
            metadata: Default::default(),
            purpose: MagicLinkPurpose.schema.json::default(),
            used_at: Default::default(),
        }
    }
}

/// MemberRole
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MemberRole {
    #[serde(rename = "admin")]
    Admin,
    #[serde(rename = "member")]
    Member,
    #[serde(rename = "guest")]
    Guest,
}

/// AccordionBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AccordionBlock {
    pub blocks: Vec<Block>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub initial_state: Option<AccordionState>,
    pub summary: PlainTextObject,
}

impl Default for AccordionBlock {
    fn default() -> Self {
        Self {
            blocks: vec![],
            initial_state: "collapsed".to_string(),
            summary: ../primitives/PlainTextObject.schema.json::default(),
        }
    }
}

/// TemporalMarkerType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TemporalMarkerType {
    absolute,
    relative,
    duration,
    frequency,
    time_of_day,
}

/// ThreadMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadMessage {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_speaker: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<serde_json::Value>,
    pub id: ThreadId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_type: Option<AgentMessageType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub role: MessageRole,
    pub thread_id: ThreadId,
    pub timestamp: String,
}

impl Default for ThreadMessage {
    fn default() -> Self {
        Self {
            agent_speaker: Default::default(),
            content: Default::default(),
            id: ../primitives/ThreadId.schema.json::default(),
            message_type: ../agentic/AgentMessageType.schema.json::default(),
            metadata: Default::default(),
            role: ../primitives/MessageRole.schema.json::default(),
            thread_id: ../primitives/ThreadId.schema.json::default(),
            timestamp: "".to_string(),
        }
    }
}

/// SegmentationMetadata
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentationMetadata {
    pub entity_count: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub language: Option<serde_json::Value>,
    pub modality: Modality,
    pub segment_count: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub speaker_count: Option<serde_json::Value>,
    pub temporal_count: i64,
}

impl Default for SegmentationMetadata {
    fn default() -> Self {
        Self {
            entity_count: 0,
            language: Default::default(),
            modality: ../primitives/Modality.schema.json::default(),
            segment_count: 0,
            speaker_count: Default::default(),
            temporal_count: 0,
        }
    }
}

/// Focus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Focus {
    pub active_since: Timestamp,
    pub amplitudes: Vec<(f64, f64)>,
    pub coherence: NormalizedFloat,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
    pub id: UUID,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    pub tenant_id: TenantId,
    pub text: String,
}

/// EntityRef
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityRef {
    pub content: String,
    pub entity_type: EntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<serde_json::Value>,
}

impl Default for EntityRef {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            entity_type: ../primitives/EntityType.schema.json::default(),
            id: Default::default(),
            timestamp: Default::default(),
        }
    }
}

/// AgentMessageType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "message_type")]
pub enum AgentMessageType {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
    Variant6,
}

/// ExportStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExportStatus {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "processing")]
    Processing,
    #[serde(rename = "ready")]
    Ready,
    #[serde(rename = "expired")]
    Expired,
    #[serde(rename = "failed")]
    Failed,
}

/// AgentResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AgentResponse {
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_type: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<serde_json::Value>,
}

impl Default for AgentResponse {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            message_type: "text".to_string(),
            options: Default::default(),
        }
    }
}

/// QueryType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryType {
    TEMPORAL,
    ENTITY,
    PATTERN,
    COMPARISON,
    SUMMARY,
    QUANTITATIVE,
    BOOLEAN,
    CAUSAL,
    SPATIAL,
    EXPLORATORY,
}

/// OverflowElement
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OverflowElement {
    pub action_id: String,
    pub options: Vec<OptionObject>,
}

/// DeletionRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DeletionRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<serde_json::Value>,
    pub created_at: String,
    pub email: Email,
    pub id: DeletionRequestId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_for: Option<serde_json::Value>,
    pub status: DeletionStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<serde_json::Value>,
}

impl Default for DeletionRequest {
    fn default() -> Self {
        Self {
            completed_at: Default::default(),
            created_at: "".to_string(),
            email: ../primitives/Email.schema.json::default(),
            id: ../primitives/DeletionRequestId.schema.json::default(),
            reason: Default::default(),
            scheduled_for: Default::default(),
            status: DeletionStatus.schema.json::default(),
            user_id: Default::default(),
        }
    }
}

/// PurposeContext
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PurposeContext {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation_history: Option<Vec<ConversationTurn>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_classifications: Option<Vec<ClassifiedPurpose>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_patterns: Option<UserPurposePatterns>,
}

impl Default for PurposeContext {
    fn default() -> Self {
        Self {
            conversation_history: vec![],
            previous_classifications: vec![],
            user_patterns: UserPurposePatterns.schema.json::default(),
        }
    }
}

/// DaemonQueueQueue
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DaemonQueueQueue(pub serde_json::Value);

/// TextObject
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum TextObject {
    Variant0,
    Variant1,
}

/// SegmentationResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentationResponse {
    pub segments: Vec<RawSegment>,
}

/// PromptPhase
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum PromptPhase {
    Segmentation,
    Purpose,
    Classification,
}

/// OrchestrationInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OrchestrationInput {
    pub request_id: String,
    pub state: AgentState,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_message: Option<serde_json::Value>,
}

impl Default for OrchestrationInput {
    fn default() -> Self {
        Self {
            request_id: "".to_string(),
            state: AgentState.schema.json::default(),
            user_message: Default::default(),
        }
    }
}

/// AudioBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AudioBlock {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration_secs: Option<serde_json::Value>,
    pub source: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcript: Option<serde_json::Value>,
}

/// BondHintOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondHintOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bond_updates: Option<Vec<BondUpdate>>,
    pub bonds: Vec<DetectedBond>,
}

impl Default for BondHintOutput {
    fn default() -> Self {
        Self {
            bond_updates: vec![],
            bonds: vec![],
        }
    }
}

/// BondHints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondHints {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reciprocity: Option<f64>,
    pub relationship_type: RelationshipType,
    pub source: ThreadReference,
    pub strength: f64,
    pub target: ThreadReference,
    pub valence: f64,
}

impl Default for BondHints {
    fn default() -> Self {
        Self {
            description: Default::default(),
            reciprocity: 0.5,
            relationship_type: ../primitives/RelationshipType.schema.json::default(),
            source: ../primitives/ThreadReference.schema.json::default(),
            strength: 0.0,
            target: ../primitives/ThreadReference.schema.json::default(),
            valence: 0.0,
        }
    }
}

/// RetryConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RetryConfig {
    pub backoff_factor: f64,
    pub initial_delay_ms: i64,
    pub max_delay_ms: i64,
    pub max_retries: i64,
}

/// ClassificationReasoning
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassificationReasoning {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explanations: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_phrases: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub main_verb: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub verb_category: Option<VerbCategory>,
}

impl Default for ClassificationReasoning {
    fn default() -> Self {
        Self {
            explanations: vec![],
            key_phrases: vec![],
            main_verb: Default::default(),
            verb_category: ../primitives/VerbCategory.schema.json::default(),
        }
    }
}

/// PhysicsHints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsHints {
    pub arousal: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certainty: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reasoning: Option<serde_json::Value>,
    pub significance: f64,
    pub valence: f64,
}

impl Default for PhysicsHints {
    fn default() -> Self {
        Self {
            arousal: 0.0,
            certainty: 0.5,
            reasoning: Default::default(),
            significance: 0.0,
            valence: 0.0,
        }
    }
}

/// EnvelopeV1
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EnvelopeV1 {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub causation_id: Option<serde_json::Value>,
    pub correlation_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub course_id: Option<serde_json::Value>,
    pub message_id: String,
    pub message_type: String,
    pub occurred_at: String,
    pub payload: Payload,
    pub producer: ProducerInfo,
    pub schema: SchemaInfo,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shuttle_id: Option<ShuttleId>,
    pub tenant_id: TenantId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread_id: Option<serde_json::Value>,
    pub user_id: UserId,
}

/// ExistingBond
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ExistingBond {
    pub head_thread_id: String,
    pub id: String,
    pub relationship_type: RelationshipType,
    pub strength: f64,
    pub tail_thread_id: String,
}

/// RelationalDynamics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RelationalDynamics {
    pub formalism: NormalizedFloat,
    pub intimacy: NormalizedFloat,
    pub power_dynamic: SignedNormalizedFloat,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_label: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spectral_signature: Option<serde_json::Value>,
    pub transparency: NormalizedFloat,
}

impl Default for RelationalDynamics {
    fn default() -> Self {
        Self {
            formalism: 0.5,
            intimacy: ../primitives/NormalizedFloat.schema.json::default(),
            power_dynamic: ../primitives/SignedNormalizedFloat.schema.json::default(),
            primary_label: Default::default(),
            spectral_signature: Default::default(),
            transparency: 0.5,
        }
    }
}

/// Message
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Message {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_speaker: Option<serde_json::Value>,
    pub channel_id: ChannelId,
    pub content: String,
    pub created_at: String,
    pub id: MessageId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_id: Option<serde_json::Value>,
    pub role: MessageRole,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sender_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking_steps: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weave_result: Option<serde_json::Value>,
}

impl Default for Message {
    fn default() -> Self {
        Self {
            agent_speaker: Default::default(),
            channel_id: ../primitives/ChannelId.schema.json::default(),
            content: "".to_string(),
            created_at: "".to_string(),
            id: ../primitives/MessageId.schema.json::default(),
            metadata: Default::default(),
            parent_id: Default::default(),
            role: ../primitives/MessageRole.schema.json::default(),
            sender_id: Default::default(),
            thinking_steps: Default::default(),
            tool_calls: Default::default(),
            weave_result: Default::default(),
        }
    }
}

/// DividerBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DividerBlock(pub serde_json::Value);

/// PublicUser
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PublicUser {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    pub id: UserId,
    pub name: String,
}

impl Default for PublicUser {
    fn default() -> Self {
        Self {
            avatar_url: Default::default(),
            id: ../primitives/UserId.schema.json::default(),
            name: "".to_string(),
        }
    }
}

/// BindingHintOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingHintOutput {
    pub bindings: Vec<DetectedBinding>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub graph_updates: Option<Vec<BindingGraphUpdate>>,
}

impl Default for BindingHintOutput {
    fn default() -> Self {
        Self {
            bindings: vec![],
            graph_updates: vec![],
        }
    }
}

/// ContinuationOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContinuationOutput {
    pub has_more_tasks: bool,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_request: Option<serde_json::Value>,
    pub state: serde_json::Value,
}

impl Default for ContinuationOutput {
    fn default() -> Self {
        Self {
            has_more_tasks: false,
            message: "".to_string(),
            next_request: Default::default(),
            state: Default::default(),
        }
    }
}

/// OnboardingEvent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum OnboardingEvent {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
    Variant6,
    Variant7,
}

/// CreateEmailInviteInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateEmailInviteInput {
    pub email: Email,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_in_days: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<InviteRole>,
    pub tenant_id: TenantId,
}

impl Default for CreateEmailInviteInput {
    fn default() -> Self {
        Self {
            email: ../primitives/Email.schema.json::default(),
            expires_in_days: 7,
            role: InviteRole.schema.json::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
        }
    }
}

/// ObservationResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ObservationResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<SegmentClassification>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub llm_request: Option<LlmRequestDebug>,
    pub message_intent: MessageIntent,
    pub metadata: ResponseMetadata,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics_hints: Option<Vec<RawPhysicsHint>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub raw_llm_response: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub segments: Option<Vec<RawSegment>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weave_units: Option<Vec<WeaveUnit>>,
}

impl Default for ObservationResponse {
    fn default() -> Self {
        Self {
            classifications: vec![],
            llm_request: LlmRequestDebug.schema.json::default(),
            message_intent: ../primitives/MessageIntent.schema.json::default(),
            metadata: ResponseMetadata.schema.json::default(),
            physics_hints: vec![],
            raw_llm_response: Default::default(),
            segments: vec![],
            weave_units: vec![],
        }
    }
}

/// ToolCallRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolCallRequest {
    pub arguments: serde_json::Value,
    pub call_id: String,
    pub tool_name: String,
}

/// WeaveBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum WeaveBlock {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
}

/// PhysicsHintInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsHintInput {
    pub content: String,
    pub entity_type: EntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_positions: Option<Vec<VAEPosition>>,
    pub segment: Segment,
}

impl Default for PhysicsHintInput {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            entity_type: ../primitives/EntityType.schema.json::default(),
            previous_positions: vec![],
            segment: ../primitives/Segment.schema.json::default(),
        }
    }
}

/// WeaveUnitResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WeaveUnitResponse {
    pub classifications: Vec<ClassificationResponse>,
    pub content: String,
    pub index: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics_hint: Option<PhysicsHintResponse>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_thread: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purpose: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_threads: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spawned_ids: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal_marker: Option<serde_json::Value>,
}

impl Default for WeaveUnitResponse {
    fn default() -> Self {
        Self {
            classifications: vec![],
            content: "".to_string(),
            index: 0,
            physics_hint: PhysicsHintResponse.schema.json::default(),
            primary_thread: Default::default(),
            purpose: Default::default(),
            secondary_threads: vec![],
            spawned_ids: vec![],
            temporal_marker: Default::default(),
        }
    }
}

/// FamiliarEntityType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum FamiliarEntityType {
    #[serde(rename = "MOMENT")]
    Moment,
    #[serde(rename = "PULSE")]
    Pulse,
    #[serde(rename = "INTENT")]
    Intent,
    #[serde(rename = "THREAD")]
    Thread,
    #[serde(rename = "BOND")]
    Bond,
    #[serde(rename = "MOTIF")]
    Motif,
    #[serde(rename = "FILAMENT")]
    Filament,
    #[serde(rename = "FOCUS")]
    Focus,
}

/// ShuttleDetails
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ShuttleDetails {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub latency_ms: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spawn_count: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tokens_used: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit_count: Option<i64>,
}

impl Default for ShuttleDetails {
    fn default() -> Self {
        Self {
            latency_ms: Default::default(),
            model: Default::default(),
            provider: Default::default(),
            spawn_count: 0,
            tokens_used: Default::default(),
            unit_count: 0,
        }
    }
}

/// RawSegment
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RawSegment {
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mentions: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal: Option<serde_json::Value>,
}

impl Default for RawSegment {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            mentions: vec![],
            subject: Default::default(),
            temporal: Default::default(),
        }
    }
}

/// SpawnSuggesterInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SpawnSuggesterInput {
    pub classification: EntityClassifierOutput,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<SpawnConfig>,
    pub segment: Segment,
}

impl Default for SpawnSuggesterInput {
    fn default() -> Self {
        Self {
            classification: EntityClassifierOutput.schema.json::default(),
            config: SpawnConfig.schema.json::default(),
            segment: ../primitives/Segment.schema.json::default(),
        }
    }
}

/// SubjectReference
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SubjectReference {
    pub confidence: f64,
    pub name: String,
    pub subject_type: SubjectType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread_id: Option<serde_json::Value>,
}

impl Default for SubjectReference {
    fn default() -> Self {
        Self {
            confidence: 0.0,
            name: "".to_string(),
            subject_type: SubjectType.schema.json::default(),
            thread_id: Default::default(),
        }
    }
}

/// ListMessagesOptions
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ListMessagesOptions {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub after: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub before: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<serde_json::Value>,
}

impl Default for ListMessagesOptions {
    fn default() -> Self {
        Self {
            after: Default::default(),
            before: Default::default(),
            limit: Default::default(),
        }
    }
}

/// AgenticEvent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "event_type")]
pub enum AgenticEvent {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
}

/// ConsentType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ConsentType {
    #[serde(rename = "terms_of_service")]
    TermsOfService,
    #[serde(rename = "privacy_policy")]
    PrivacyPolicy,
    #[serde(rename = "marketing_emails")]
    MarketingEmails,
    #[serde(rename = "ai_processing")]
    AiProcessing,
    #[serde(rename = "data_sharing")]
    DataSharing,
    #[serde(rename = "analytics")]
    Analytics,
}

/// Block
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum Block {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
    Variant6,
    Variant7,
}

/// SegmentationOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentationOutput {
    pub metadata: SegmentationMetadata,
    pub segments: Vec<Segment>,
}

/// AIProvider
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum AIProvider {
    #[serde(rename = "openai")]
    Openai,
    #[serde(rename = "anthropic")]
    Anthropic,
    #[serde(rename = "google")]
    Google,
    #[serde(rename = "mock")]
    Mock,
}

/// MagicLinkModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLinkModel {
    pub created_at: String,
    pub email: Email,
    pub expires_at: String,
    pub id: MagicLinkId,
    pub metadata: serde_json::Value,
    pub purpose: MagicLinkPurpose,
    pub token_hash: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub used_at: Option<serde_json::Value>,
}

/// EntityType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum EntityType {
    MOMENT,
    PULSE,
    THREAD,
    BOND,
    MOTIF,
    FILAMENT,
    FOCUS,
    INTENT,
}

/// MarkdownTextObject
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MarkdownTextObject {
    pub text: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub verbatim: Option<bool>,
}

impl Default for MarkdownTextObject {
    fn default() -> Self {
        Self {
            text: "".to_string(),
            verbatim: false,
        }
    }
}

/// HeaderBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct HeaderBlock {
    pub text: PlainTextObject,
}

/// Motif
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Motif {
    pub amplitudes: Vec<(f64, f64)>,
    pub coherence: NormalizedFloat,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
    pub id: UUID,
    pub metadata: serde_json::Value,
    pub physics: FieldExcitation,
    pub source_moments: Vec<UUID>,
    pub tenant_id: TenantId,
    pub text: String,
}

/// QueryFilter
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QueryFilter {
    pub field: String,
    pub operator: FilterOperator,
    pub value: serde_json::Value,
}

/// CreateChannelInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateChannelInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_type: Option<ChannelType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<serde_json::Value>,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner_id: Option<serde_json::Value>,
    pub tenant_id: TenantId,
}

impl Default for CreateChannelInput {
    fn default() -> Self {
        Self {
            channel_type: ../entities/ChannelType.schema.json::default(),
            description: Default::default(),
            name: "".to_string(),
            owner_id: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
        }
    }
}

/// CreateMessageInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateMessageInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_speaker: Option<serde_json::Value>,
    pub channel_id: ChannelId,
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_id: Option<serde_json::Value>,
    pub role: MessageRole,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sender_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking_steps: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weave_result: Option<serde_json::Value>,
}

impl Default for CreateMessageInput {
    fn default() -> Self {
        Self {
            agent_speaker: Default::default(),
            channel_id: ../primitives/ChannelId.schema.json::default(),
            content: "".to_string(),
            metadata: Default::default(),
            parent_id: Default::default(),
            role: ../primitives/MessageRole.schema.json::default(),
            sender_id: Default::default(),
            thinking_steps: Default::default(),
            tool_calls: Default::default(),
            weave_result: Default::default(),
        }
    }
}

/// ThreadHintValues
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadHintValues {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub categories: Option<Vec<ThreadCategory>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub create_if_missing: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keywords: Option<Vec<String>>,
    pub primary_subject: SubjectReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub related_threads: Option<Vec<ThreadReference>>,
    pub thread_role: ThreadRole,
}

impl Default for ThreadHintValues {
    fn default() -> Self {
        Self {
            categories: vec![],
            create_if_missing: false,
            keywords: vec![],
            primary_subject: SubjectReference.schema.json::default(),
            related_threads: vec![],
            thread_role: ../primitives/ThreadRole.schema.json::default(),
        }
    }
}

/// ConditionType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ConditionType {
    output_value,
    step_success,
    step_failed,
    output_exists,
}

/// UIThinkingStep
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIThinkingStep {
    pub agent: String,
    pub id: String,
    pub thought: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<serde_json::Value>,
}

impl Default for UIThinkingStep {
    fn default() -> Self {
        Self {
            agent: "".to_string(),
            id: "".to_string(),
            thought: "".to_string(),
            timestamp: Default::default(),
        }
    }
}

/// EntityPhysics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityPhysics {
    pub arousal: f64,
    pub epistemic: f64,
    pub significance: f64,
    pub valence: f64,
}

/// DetectedEmotion
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedEmotion {
    pub emotion: String,
    pub evidence: String,
    pub intensity: f64,
}

/// FilterOperator
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum FilterOperator {
    #[serde(rename = "equals")]
    Equals,
    #[serde(rename = "not_equals")]
    NotEquals,
    #[serde(rename = "contains")]
    Contains,
    #[serde(rename = "starts_with")]
    StartsWith,
    #[serde(rename = "ends_with")]
    EndsWith,
    #[serde(rename = "greater_than")]
    GreaterThan,
    #[serde(rename = "less_than")]
    LessThan,
    #[serde(rename = "between")]
    Between,
    #[serde(rename = "in")]
    In_,
    #[serde(rename = "not_in")]
    NotIn,
}

/// ToolChainStep
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolChainStep {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub condition: Option<StepCondition>,
    pub execution_order: ExecutionOrder,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_mapping: Option<Vec<InputMapping>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parallel_with: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout_ms: Option<serde_json::Value>,
    pub tool: String,
}

impl Default for ToolChainStep {
    fn default() -> Self {
        Self {
            condition: StepCondition.schema.json::default(),
            execution_order: ExecutionOrder.schema.json::default(),
            id: "".to_string(),
            input_mapping: vec![],
            parallel_with: vec![],
            required: true,
            timeout_ms: Default::default(),
            tool: "".to_string(),
        }
    }
}

/// UIHeddleResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIHeddleResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classifications: Option<Vec<UIClassification>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics: Option<UIPhysicsResult>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purpose: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub segments: Option<Vec<UIHeddleSegment>>,
}

impl Default for UIHeddleResult {
    fn default() -> Self {
        Self {
            classifications: vec![],
            physics: ../primitives/UIPhysicsResult.schema.json::default(),
            purpose: Default::default(),
            segments: vec![],
        }
    }
}

/// Timestamps
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Timestamps {
    pub created_at: String,
    pub updated_at: String,
}

/// UpdateEntityStatusInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UpdateEntityStatusInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_by: Option<serde_json::Value>,
    pub status: EntityStatus,
}

impl Default for UpdateEntityStatusInput {
    fn default() -> Self {
        Self {
            reviewed_by: Default::default(),
            status: ../entities/EntityStatus.schema.json::default(),
        }
    }
}

/// TraceKind
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TraceKind {
    step,
    thought,
    tool,
    token,
    error,
    metric,
}

/// CourseMetadata
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CourseMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_pinned: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_language: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tokenizer_hint: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_history_tokens: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ui_theme: Option<serde_json::Value>,
}

impl Default for CourseMetadata {
    fn default() -> Self {
        Self {
            custom: Default::default(),
            is_pinned: false,
            preferred_language: Default::default(),
            tags: vec![],
            tokenizer_hint: Default::default(),
            total_history_tokens: 0,
            ui_theme: Default::default(),
        }
    }
}

/// CreateMemberInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateMemberInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<serde_json::Value>,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<MemberRole>,
    pub tenant_id: TenantId,
    pub user_id: UserId,
}

impl Default for CreateMemberInput {
    fn default() -> Self {
        Self {
            avatar_url: Default::default(),
            email: Default::default(),
            name: "".to_string(),
            role: ../types/MemberRole.schema.json::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            user_id: ../primitives/UserId.schema.json::default(),
        }
    }
}

/// Casing
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum Casing {
    #[serde(rename = "snake_case")]
    SnakeCase,
    #[serde(rename = "camelCase")]
    CamelCase,
    PascalCase,
    #[serde(rename = "SCREAMING_SNAKE_CASE")]
    ScreamingSnakeCase,
    #[serde(rename = "kebab-case")]
    KebabCase,
}

/// ThreadRelationType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ThreadRelationType {
    part_of,
    contains,
    related_to,
    causes_of,
    opposite_of,
    same_as,
}

/// ClassificationEvidence
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassificationEvidence {
    pub description: String,
    pub evidence_type: EvidenceType,
    pub weight: f64,
}

/// SignupFlowInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SignupFlowInput {
    pub consents: SignupConsents,
    pub email: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<serde_json::Value>,
    pub request_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
}

/// MagicLinkPurpose
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MagicLinkPurpose {
    #[serde(rename = "login")]
    Login,
    #[serde(rename = "signup")]
    Signup,
    #[serde(rename = "verify_email")]
    VerifyEmail,
    #[serde(rename = "password_reset")]
    PasswordReset,
}

/// HealthResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct HealthResponse {
    pub service: String,
    pub status: String,
    pub version: String,
}

/// BondPhysics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondPhysics {
    pub bond_strength: NormalizedFloat,
    pub damping_coefficient: f64,
    pub spring_constant: f64,
}

impl Default for BondPhysics {
    fn default() -> Self {
        Self {
            bond_strength: 0.5,
            damping_coefficient: 0.5,
            spring_constant: 1,
        }
    }
}

/// VerbTense
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum VerbTense {
    #[serde(rename = "past")]
    Past,
    #[serde(rename = "present")]
    Present,
    #[serde(rename = "future")]
    Future,
    #[serde(rename = "habitual")]
    Habitual,
}

/// PhysicsAnalysis
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsAnalysis {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certainty_indicators: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub emotions: Option<Vec<DetectedEmotion>>,
    pub reasoning: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub significance_indicators: Option<Vec<String>>,
}

impl Default for PhysicsAnalysis {
    fn default() -> Self {
        Self {
            certainty_indicators: vec![],
            emotions: vec![],
            reasoning: "".to_string(),
            significance_indicators: vec![],
        }
    }
}

/// DetectedThread
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedThread {
    pub confidence: f64,
    pub detection_method: DetectionMethod,
    pub role: MemberRole,
    pub thread: ThreadReference,
    pub trigger_text: String,
}

/// ToolCategory
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ToolCategory {
    segmentation,
    classification,
    spawn,
    hints,
    retrieval,
    orchestration,
}

/// SubjectType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum SubjectType {
    self_,
    person,
    place,
    organization,
    concept,
    event,
    object,
    other,
}

/// QuantumState
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QuantumState {
    pub amplitudes: Vec<(f64, f64)>,
    pub coherence: NormalizedFloat,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
}

/// PlainTextObject
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PlainTextObject {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub emoji: Option<bool>,
    pub text: String,
}

impl Default for PlainTextObject {
    fn default() -> Self {
        Self {
            emoji: false,
            text: "".to_string(),
        }
    }
}

/// RawPhysicsHint
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RawPhysicsHint {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arousal: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub clarity: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intrusiveness: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub significance: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valence: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub volatility: Option<serde_json::Value>,
}

impl Default for RawPhysicsHint {
    fn default() -> Self {
        Self {
            arousal: Default::default(),
            clarity: Default::default(),
            intrusiveness: Default::default(),
            significance: Default::default(),
            valence: Default::default(),
            volatility: Default::default(),
        }
    }
}

/// SegmentationInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentationInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<SegmentationConfig>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<SegmentationContext>,
    pub input: ModalityInput,
}

impl Default for SegmentationInput {
    fn default() -> Self {
        Self {
            config: SegmentationConfig.schema.json::default(),
            context: SegmentationContext.schema.json::default(),
            input: ModalityInput.schema.json::default(),
        }
    }
}

/// CommandResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CommandResult {
    pub accepted: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub course_id: Option<CourseId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ws_url: Option<serde_json::Value>,
}

impl Default for CommandResult {
    fn default() -> Self {
        Self {
            accepted: false,
            course_id: ../primitives/CourseId.schema.json::default(),
            error: Default::default(),
            job_id: Default::default(),
            thread_id: Default::default(),
            ws_url: Default::default(),
        }
    }
}

/// WeightedClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WeightedClassification {
    pub entity_type: HeddleEntityType,
    pub weight: NormalizedFloat,
}

/// AuthSessionModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AuthSessionModel {
    pub created_at: String,
    pub expires_at: String,
    pub id: SessionId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    pub token_hash: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
    pub user_id: UserId,
    pub version: i64,
}

/// ParameterType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ParameterType(pub serde_json::Value);

/// KnownEntity
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct KnownEntity {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    pub entity_type: String,
    pub id: String,
    pub name: String,
}

impl Default for KnownEntity {
    fn default() -> Self {
        Self {
            aliases: vec![],
            entity_type: "".to_string(),
            id: "".to_string(),
            name: "".to_string(),
        }
    }
}

/// MagicLinkCreated
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLinkCreated {
    pub expires_at: String,
    pub link_id: String,
    pub token: String,
}

/// SimLOD
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SimLOD {
    pub last_update: i64,
    pub tier: SimulationTier,
}

/// ToolParameter
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolParameter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub constraints: Option<ParameterConstraints>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_value: Option<serde_json::Value>,
    pub description: String,
    pub name: String,
    pub param_type: ParameterType,
    pub required: bool,
}

impl Default for ToolParameter {
    fn default() -> Self {
        Self {
            constraints: ParameterConstraints.schema.json::default(),
            default_value: Default::default(),
            description: "".to_string(),
            name: "".to_string(),
            param_type: ParameterType.schema.json::default(),
            required: false,
        }
    }
}

/// EntityClassifierInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityClassifierInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<EntityClassificationContext>,
    pub purpose: ClassifiedPurpose,
    pub segment: Segment,
}

impl Default for EntityClassifierInput {
    fn default() -> Self {
        Self {
            context: EntityClassificationContext.schema.json::default(),
            purpose: ClassifiedPurpose.schema.json::default(),
            segment: ../primitives/Segment.schema.json::default(),
        }
    }
}

/// ContinuationInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContinuationInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_request: Option<serde_json::Value>,
    pub request_id: String,
    pub state: serde_json::Value,
}

impl Default for ContinuationInput {
    fn default() -> Self {
        Self {
            original_request: Default::default(),
            request_id: "".to_string(),
            state: Default::default(),
        }
    }
}

/// InputMapping
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct InputMapping {
    pub from_path: String,
    pub from_step: String,
    pub to_path: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transform: Option<InputTransform>,
}

impl Default for InputMapping {
    fn default() -> Self {
        Self {
            from_path: "".to_string(),
            from_step: "".to_string(),
            to_path: "".to_string(),
            transform: InputTransform.schema.json::default(),
        }
    }
}

/// RAGOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RAGOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub done: Option<bool>,
    pub query: String,
    pub response_message: String,
    pub results: Vec<RAGResult>,
    pub state: serde_json::Value,
    pub total_count: i64,
}

impl Default for RAGOutput {
    fn default() -> Self {
        Self {
            done: true,
            query: "".to_string(),
            response_message: "".to_string(),
            results: vec![],
            state: Default::default(),
            total_count: 0,
        }
    }
}

/// ProviderConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ProviderConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_key: Option<ApiKey>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_version: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub organization_id: Option<serde_json::Value>,
    pub provider: AIProvider,
}

/// DetectedBond
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedBond {
    pub characteristics: BondCharacteristics,
    pub confidence: f64,
    pub evidence: BondEvidence,
    pub head: ThreadReference,
    pub tail: ThreadReference,
}

/// SystemMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SystemMeta {
    #[serde(rename = "$schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_schema: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub title: String,
    #[serde(rename = "x-familiar-depends")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_depends: Option<Vec<serde_json::Value>>,
    #[serde(rename = "x-familiar-input")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_input: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-kind")]
    pub x_familiar_kind: String,
    #[serde(rename = "x-familiar-output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_output: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-queue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_queue: Option<String>,
    #[serde(rename = "x-familiar-reads")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_reads: Option<Vec<serde_json::Value>>,
    #[serde(rename = "x-familiar-retries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_retries: Option<i64>,
    #[serde(rename = "x-familiar-service")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_service: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-timeout")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_timeout: Option<String>,
    #[serde(rename = "x-familiar-writes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_writes: Option<Vec<serde_json::Value>>,
}

impl Default for SystemMeta {
    fn default() -> Self {
        Self {
            schema_schema: "".to_string(),
            description: "".to_string(),
            title: "".to_string(),
            x_familiar_depends: vec![],
            x_familiar_input: serde_json::Value::Null,
            x_familiar_kind: "".to_string(),
            x_familiar_output: serde_json::Value::Null,
            x_familiar_queue: "".to_string(),
            x_familiar_reads: vec![],
            x_familiar_retries: 3,
            x_familiar_service: serde_json::Value::Null,
            x_familiar_timeout: "".to_string(),
            x_familiar_writes: vec![],
        }
    }
}

/// TemporalRelation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TemporalRelation {
    #[serde(rename = "before")]
    Before,
    #[serde(rename = "after")]
    After,
    #[serde(rename = "during")]
    During,
    #[serde(rename = "simultaneous")]
    Simultaneous,
    #[serde(rename = "overlapping")]
    Overlapping,
}

/// Channel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Channel {
    pub channel_type: ChannelType,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<serde_json::Value>,
    pub id: ChannelId,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings: Option<serde_json::Value>,
    pub tenant_id: TenantId,
    pub updated_at: String,
}

impl Default for Channel {
    fn default() -> Self {
        Self {
            channel_type: ../entities/ChannelType.schema.json::default(),
            created_at: "".to_string(),
            description: Default::default(),
            id: ../primitives/ChannelId.schema.json::default(),
            name: "".to_string(),
            owner_id: Default::default(),
            settings: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            updated_at: "".to_string(),
        }
    }
}

/// PhysicsHint
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsHint {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arousal: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub clarity: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intrusiveness: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub significance: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valence: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub volatility: Option<serde_json::Value>,
}

/// UIThreadItem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIThreadItem {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_speaker: Option<serde_json::Value>,
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_activity: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub heddle_result: Option<UIHeddleResult>,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_typing: Option<bool>,
    pub role: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking_steps: Option<Vec<UIThinkingStep>>,
    pub timestamp: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<UIToolCall>>,
}

impl Default for UIThreadItem {
    fn default() -> Self {
        Self {
            agent_speaker: Default::default(),
            content: "".to_string(),
            current_activity: Default::default(),
            heddle_result: UIHeddleResult.schema.json::default(),
            id: "".to_string(),
            is_typing: false,
            role: "".to_string(),
            status: Default::default(),
            summary: Default::default(),
            thinking_steps: vec![],
            timestamp: "".to_string(),
            tool_calls: vec![],
        }
    }
}

/// PromptConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PromptConfig {
    pub max_tokens: i64,
    pub model: String,
    pub phase: PromptPhase,
    pub temperature: f64,
}

/// ConditionOperator
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ConditionOperator {
    #[serde(rename = "equals")]
    Equals,
    #[serde(rename = "not_equals")]
    NotEquals,
    #[serde(rename = "greater_than")]
    GreaterThan,
    #[serde(rename = "less_than")]
    LessThan,
    #[serde(rename = "contains")]
    Contains,
    #[serde(rename = "not_contains")]
    NotContains,
    #[serde(rename = "is_null")]
    IsNull,
    #[serde(rename = "is_not_null")]
    IsNotNull,
    #[serde(rename = "in")]
    In_,
}

/// EntityResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityResponse {
    pub content_preview: String,
    pub entity_type: String,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics: Option<PhysicsResponse>,
    pub unit_index: i64,
}

/// ListEntitiesOptions
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ListEntitiesOptions {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_type: Option<FamiliarEntityType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<EntityStatus>,
}

impl Default for ListEntitiesOptions {
    fn default() -> Self {
        Self {
            entity_type: ../entities/FamiliarEntityType.schema.json::default(),
            limit: Default::default(),
            status: ../entities/EntityStatus.schema.json::default(),
        }
    }
}

/// ConsentRecord
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConsentRecord {
    pub consent_type: ConsentType,
    pub created_at: String,
    pub granted: bool,
    pub id: ConsentRecordId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
    pub user_id: UserId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<serde_json::Value>,
}

impl Default for ConsentRecord {
    fn default() -> Self {
        Self {
            consent_type: ../entities/ConsentType.schema.json::default(),
            created_at: "".to_string(),
            granted: false,
            id: ../primitives/ConsentRecordId.schema.json::default(),
            ip_address: Default::default(),
            user_agent: Default::default(),
            user_id: ../primitives/UserId.schema.json::default(),
            version: Default::default(),
        }
    }
}

/// CourseDetails
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CourseDetails {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub latency_ms: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spawn_count: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit_count: Option<i64>,
}

impl Default for CourseDetails {
    fn default() -> Self {
        Self {
            latency_ms: 0,
            model: Default::default(),
            provider: Default::default(),
            spawn_count: 0,
            unit_count: 0,
        }
    }
}

/// ContextWindowInfo
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContextWindowInfo {
    pub max_tokens: i64,
    pub messages: Vec<MessageTokenInfo>,
    pub messages_included: i64,
    pub tokens_used: i64,
    pub total_messages: i64,
    pub total_tokens: i64,
}

/// OrchestrationOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OrchestrationOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forwarded_message: Option<serde_json::Value>,
    pub next_speaker: String,
    pub should_continue: bool,
    pub state: AgentState,
}

impl Default for OrchestrationOutput {
    fn default() -> Self {
        Self {
            forwarded_message: Default::default(),
            next_speaker: "".to_string(),
            should_continue: false,
            state: AgentState.schema.json::default(),
        }
    }
}

/// SignupFlowOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SignupFlowOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub joined_family_id: Option<TenantId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub joined_family_name: Option<serde_json::Value>,
    pub needs_family: bool,
    pub session_expires_at: Timestamp,
    pub session_token: String,
    pub user_id: UserId,
}

/// ButtonStyle
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ButtonStyle {
    #[serde(rename = "primary")]
    Primary,
    #[serde(rename = "danger")]
    Danger,
}

/// BondEvidence
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondEvidence {
    pub indicator_type: BondIndicatorType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub indicators: Option<Vec<String>>,
    pub trigger_text: String,
}

impl Default for BondEvidence {
    fn default() -> Self {
        Self {
            indicator_type: BondIndicatorType.schema.json::default(),
            indicators: vec![],
            trigger_text: "".to_string(),
        }
    }
}

/// ModelConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ModelConfig {
    pub api_model_id: String,
    pub context_window: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<bool>,
    pub id: String,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notes: Option<serde_json::Value>,
    pub provider: AIProvider,
    pub supports_json_mode: bool,
}

impl Default for ModelConfig {
    fn default() -> Self {
        Self {
            api_model_id: "".to_string(),
            context_window: 0,
            deprecated: false,
            id: "".to_string(),
            name: "".to_string(),
            notes: Default::default(),
            provider: ../primitives/AIProvider.schema.json::default(),
            supports_json_mode: false,
        }
    }
}

/// SegmentationConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentationConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_entities: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extract_temporal: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub language: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_segments: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min_segment_length: Option<serde_json::Value>,
}

impl Default for SegmentationConfig {
    fn default() -> Self {
        Self {
            extract_entities: true,
            extract_temporal: true,
            language: Default::default(),
            max_segments: 20,
            min_segment_length: Default::default(),
        }
    }
}

/// SuggestedThread
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SuggestedThread {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    pub category: ThreadCategory,
    pub confidence: f64,
    pub name: String,
    pub reason: String,
    pub thread_type: ThreadType,
}

impl Default for SuggestedThread {
    fn default() -> Self {
        Self {
            aliases: vec![],
            category: ThreadCategory.schema.json::default(),
            confidence: 0.0,
            name: "".to_string(),
            reason: "".to_string(),
            thread_type: ../types/ThreadType.schema.json::default(),
        }
    }
}

/// ThreadRole
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ThreadRole {
    actor,
    subject,
    observer,
    target,
    setting,
    instrument,
}

/// TaskDynamics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TaskDynamics {
    pub activation_energy: NormalizedFloat,
    pub completion: NormalizedFloat,
    pub entropy: NormalizedFloat,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_status_label: Option<serde_json::Value>,
}

/// SpawnAction
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum SpawnAction {
    auto_spawn,
    suggest,
    skip,
    clarify,
}

/// UIToolCall
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIToolCall {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<serde_json::Value>,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<serde_json::Value>,
    pub status: ToolCallStatus,
    pub tool: String,
}

/// UIPhysicsResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIPhysicsResult {
    pub energy: f64,
    pub position: [f64; 3],
    pub temperature: f64,
}

/// ThreadSummary
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadSummary {
    pub id: ThreadId,
    pub is_open: bool,
    pub message_count: i64,
    pub preview: String,
    pub updated_at: String,
}

/// AgenticCommand
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "command_type")]
pub enum AgenticCommand {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
}

/// RawClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RawClassification {
    pub entity_type: HeddleEntityType,
    pub weight: f64,
}

/// InviteType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum InviteType {
    #[serde(rename = "email")]
    Email,
    #[serde(rename = "code")]
    Code,
}

/// ClassificationResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassificationResult {
    pub entity_type: String,
    pub probability: f64,
}

/// ConversationThread
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConversationThread {
    pub created_at: String,
    pub id: ThreadId,
    pub is_open: bool,
    pub messages: Vec<ThreadMessage>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub parent_message_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<serde_json::Value>,
    pub tenant_id: TenantId,
    pub updated_at: String,
}

impl Default for ConversationThread {
    fn default() -> Self {
        Self {
            created_at: "".to_string(),
            id: ../primitives/ThreadId.schema.json::default(),
            is_open: false,
            messages: vec![],
            metadata: Default::default(),
            parent_message_id: "".to_string(),
            summary: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            updated_at: "".to_string(),
        }
    }
}

/// SegmentFeatures
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentFeatures {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub emotional_tone: Option<EmotionalTone>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keywords: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub language: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mentions: Option<Vec<EntityMention>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal_markers: Option<Vec<TemporalMarker>>,
}

impl Default for SegmentFeatures {
    fn default() -> Self {
        Self {
            emotional_tone: #/definitions/EmotionalTone::default(),
            keywords: vec![],
            language: Default::default(),
            mentions: vec![],
            subject: Default::default(),
            temporal_markers: vec![],
        }
    }
}

/// MediaType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MediaType {
    Image,
    Audio,
    Document,
    Webpage,
}

/// SegmentClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentClassification {
    pub entity_type: HeddleEntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics: Option<ClassificationPhysics>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purpose: Option<MessageIntent>,
    pub segment_index: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weight: Option<f64>,
}

impl Default for SegmentClassification {
    fn default() -> Self {
        Self {
            entity_type: ../primitives/HeddleEntityType.schema.json::default(),
            physics: ../types/ClassificationPhysics.schema.json::default(),
            purpose: "LOG".to_string(),
            segment_index: 0,
            weight: 1,
        }
    }
}

/// ThreadType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ThreadType {
    Person,
    Place,
    Concept,
    GenericObject,
}

/// ResponseMetadata
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ResponseMetadata {
    pub latency_ms: i64,
    pub model_id: String,
    pub model_name: String,
    pub provider: AIProvider,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<TokenUsage>,
}

/// JoinRequestStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum JoinRequestStatus {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "approved")]
    Approved,
    #[serde(rename = "rejected")]
    Rejected,
}

/// EntityClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityClassification {
    pub entity_type: EntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evidence: Option<Vec<ClassificationEvidence>>,
    pub probability: f64,
}

impl Default for EntityClassification {
    fn default() -> Self {
        Self {
            entity_type: ../primitives/EntityType.schema.json::default(),
            evidence: vec![],
            probability: 0.0,
        }
    }
}

/// AgentState
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AgentState {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conversation_context: Option<Vec<ConversationTurn>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_speaker: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_authenticated: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub just_finished: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub tenant_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread_id: Option<serde_json::Value>,
}

impl Default for AgentState {
    fn default() -> Self {
        Self {
            conversation_context: vec![],
            current_speaker: Default::default(),
            is_authenticated: false,
            just_finished: false,
            metadata: Default::default(),
            tenant_id: "".to_string(),
            thread_id: Default::default(),
        }
    }
}

/// BindingHintInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingHintInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context_window: Option<ContextWindow>,
    pub current_entity: EntityRef,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recent_entities: Option<Vec<EntityRef>>,
    pub segment: Segment,
}

impl Default for BindingHintInput {
    fn default() -> Self {
        Self {
            context_window: ContextWindow.schema.json::default(),
            current_entity: EntityRef.schema.json::default(),
            recent_entities: vec![],
            segment: ../primitives/Segment.schema.json::default(),
        }
    }
}

/// ComponentMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ComponentMeta {
    #[serde(rename = "$schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_schema: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub depends_on: Option<Vec<String>>,
    pub description: String,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requires_llm: Option<bool>,
    pub rust_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub singleton: Option<bool>,
    pub version: String,
}

impl Default for ComponentMeta {
    fn default() -> Self {
        Self {
            schema_schema: "".to_string(),
            config: serde_json::Value::Null,
            depends_on: vec![],
            description: "".to_string(),
            name: "".to_string(),
            requires_llm: false,
            rust_type: "".to_string(),
            singleton: true,
            version: "".to_string(),
        }
    }
}

/// DetectedBinding
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedBinding {
    pub binding: BindingCharacteristics,
    pub confidence: f64,
    pub evidence: BindingEvidence,
    pub source: EntityRef,
    pub target: EntityRef,
}

/// ConsentStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConsentStatus {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ai_processing: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analytics: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data_sharing: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketing_emails: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub privacy_policy: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub terms_of_service: Option<serde_json::Value>,
}

/// CommandType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum CommandType {
    CREATE,
    UPDATE,
    DELETE,
    LINK,
    UNLINK,
    EXPORT,
    IMPORT,
    CONFIGURE,
    CUSTOM,
}

/// RelationshipDuration
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RelationshipDuration {
    pub category: DurationCategory,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub years: Option<serde_json::Value>,
}

impl Default for RelationshipDuration {
    fn default() -> Self {
        Self {
            category: DurationCategory.schema.json::default(),
            since: Default::default(),
            years: Default::default(),
        }
    }
}

/// TriggerType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TriggerType {
    purpose,
    modality,
    entity_type,
    keyword,
    custom,
}

/// TimeGap
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TimeGap {
    pub approximate: bool,
    pub unit: TimeUnit,
    pub value: f64,
}

/// CreateJoinRequestInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateJoinRequestInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<serde_json::Value>,
    pub tenant_id: TenantId,
}

impl Default for CreateJoinRequestInput {
    fn default() -> Self {
        Self {
            message: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
        }
    }
}

/// OpenAIMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OpenAIMessage {
    pub content: String,
    pub role: String,
}

/// RequestDeletionInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RequestDeletionInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<serde_json::Value>,
}

impl Default for RequestDeletionInput {
    fn default() -> Self {
        Self {
            reason: Default::default(),
        }
    }
}

/// OnboardingState
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum OnboardingState {
    #[serde(rename = "initial")]
    Initial,
    #[serde(rename = "email_submitted")]
    EmailSubmitted,
    #[serde(rename = "magic_link_sent")]
    MagicLinkSent,
    #[serde(rename = "credentials_set")]
    CredentialsSet,
    #[serde(rename = "signup_complete")]
    SignupComplete,
    #[serde(rename = "invite_code_entered")]
    InviteCodeEntered,
    #[serde(rename = "family_choice")]
    FamilyChoice,
    #[serde(rename = "creating_family")]
    CreatingFamily,
    #[serde(rename = "joining_family")]
    JoiningFamily,
    #[serde(rename = "request_submitted")]
    RequestSubmitted,
    #[serde(rename = "complete")]
    Complete,
}

/// SemanticProperties
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SemanticProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relationship_description: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_concepts: Option<Vec<String>>,
    pub similarity: f64,
}

impl Default for SemanticProperties {
    fn default() -> Self {
        Self {
            relationship_description: Default::default(),
            shared_concepts: vec![],
            similarity: 0.0,
        }
    }
}

/// ConversationTurn
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConversationTurn {
    pub content: String,
    pub role: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub speaker: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<serde_json::Value>,
}

impl Default for ConversationTurn {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            role: "".to_string(),
            speaker: Default::default(),
            timestamp: Default::default(),
        }
    }
}

/// EntityContent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityContent {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enriched_text: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<String>>,
    pub text: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<serde_json::Value>,
}

impl Default for EntityContent {
    fn default() -> Self {
        Self {
            enriched_text: Default::default(),
            tags: vec![],
            text: "".to_string(),
            title: Default::default(),
        }
    }
}

/// RequestConfig
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RequestConfig {
    pub json_mode: bool,
    pub max_tokens: MaxTokens,
    pub model: ModelConfig,
    pub retry: RetryConfig,
    pub temperature: Temperature,
    pub timeout_ms: i64,
}

/// ObservationRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ObservationRequest {
    pub config: RequestConfig,
    pub context: String,
    pub segment: String,
}

/// VisionSegmentFeatures
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct VisionSegmentFeatures {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<DetectedAction>>,
    pub objects: Vec<DetectedObject>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub people: Option<Vec<DetectedPerson>>,
    pub scene_description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text_content: Option<serde_json::Value>,
}

impl Default for VisionSegmentFeatures {
    fn default() -> Self {
        Self {
            actions: vec![],
            objects: vec![],
            people: vec![],
            scene_description: "".to_string(),
            text_content: Default::default(),
        }
    }
}

/// BondHintInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondHintInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub known_bonds: Option<Vec<ExistingBond>>,
    pub segment: Segment,
    pub threads: Vec<ThreadReference>,
}

impl Default for BondHintInput {
    fn default() -> Self {
        Self {
            known_bonds: vec![],
            segment: ../primitives/Segment.schema.json::default(),
            threads: vec![],
        }
    }
}

/// UserMembership
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UserMembership {
    pub is_primary: bool,
    pub joined_at: String,
    pub role: InviteRole,
    pub tenant_id: TenantId,
    pub tenant_name: String,
}

/// CreateAsyncTaskInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateAsyncTaskInput {
    pub correlation_id: String,
    pub input: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_attempts: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub task_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<TenantId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<UserId>,
}

/// GraphUpdateType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum GraphUpdateType {
    add_binding,
    strengthen_binding,
    weaken_binding,
    remove_binding,
    merge_bindings,
}

/// SectionBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SectionBlock {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub accessory: Option<BlockElement>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fields: Option<serde_json::Value>,
    pub text: TextObject,
}

/// DbStoreError
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum DbStoreError {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
    Variant6,
    Variant7,
}

/// AcceptInvitationFlowOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AcceptInvitationFlowOutput {
    pub personal_channel_id: ChannelId,
    pub role: String,
    pub tenant_id: TenantId,
    pub tenant_name: String,
}

/// CurrentUser
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CurrentUser {
    pub memberships: Vec<UserMembership>,
    pub user: User,
}

/// SystemDomain
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum SystemDomain {
    #[serde(rename = "ingestion")]
    Ingestion,
    #[serde(rename = "physics")]
    Physics,
    #[serde(rename = "analysis")]
    Analysis,
    #[serde(rename = "maintenance")]
    Maintenance,
}

/// QuantumStateModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QuantumStateModel {
    pub coherence: f64,
    pub entity_id: EntityId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<serde_json::Value>,
}

/// BondIndicatorType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum BondIndicatorType {
    explicit_label,
    relational_action,
    emotional_language,
    possessive_language,
    frequency_indicator,
    contextual_inference,
}

/// PhysicsResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsResponse {
    pub amplitude: f64,
    pub energy: f64,
    pub position: [f64; 3],
    pub temperature: f64,
}

/// SimulationTier
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum SimulationTier {
    #[serde(rename = "conscious")]
    Conscious,
    #[serde(rename = "subconscious")]
    Subconscious,
    #[serde(rename = "deep_storage")]
    DeepStorage,
}

/// IdentifiedVerb
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct IdentifiedVerb {
    pub category: VerbCategory,
    pub is_main: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tense: Option<VerbTense>,
    pub text: String,
}

impl Default for IdentifiedVerb {
    fn default() -> Self {
        Self {
            category: ../primitives/VerbCategory.schema.json::default(),
            is_main: false,
            tense: VerbTense.schema.json::default(),
            text: "".to_string(),
        }
    }
}

/// AuditLogEntryModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AuditLogEntryModel {
    pub action: String,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<serde_json::Value>,
    pub id: AuditLogId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    pub metadata: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_type: Option<serde_json::Value>,
    pub success: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_email: Option<Email>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<UserId>,
}

/// CreateTenantInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateTenantInput {
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings: Option<serde_json::Value>,
}

/// SystemTrigger
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SystemTrigger(pub serde_json::Value);

/// CreateFamilyFlowOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateFamilyFlowOutput {
    pub channel_id: ChannelId,
    pub channel_name: String,
    pub tenant_id: TenantId,
    pub tenant_name: String,
}

/// MagicLinkConsumeOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLinkConsumeOutput {
    pub email: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<serde_json::Value>,
    pub is_new_user: bool,
    pub needs_family: bool,
    pub session_expires_at: Timestamp,
    pub session_token: String,
    pub user_id: UserId,
}

/// BondUpdate
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondUpdate {
    pub bond_id: String,
    pub changes: BondChanges,
    pub reason: String,
}

/// BondCharacteristics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondCharacteristics {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<RelationshipDuration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interaction_frequency: Option<InteractionFrequency>,
    pub intimacy: f64,
    pub reciprocity: f64,
    pub relationship_type: RelationshipType,
    pub strength: f64,
    pub trust: f64,
    pub valence: f64,
}

impl Default for BondCharacteristics {
    fn default() -> Self {
        Self {
            duration: RelationshipDuration.schema.json::default(),
            interaction_frequency: InteractionFrequency.schema.json::default(),
            intimacy: 0.0,
            reciprocity: 0.0,
            relationship_type: ../primitives/RelationshipType.schema.json::default(),
            strength: 0.0,
            trust: 0.0,
            valence: 0.0,
        }
    }
}

/// SpawnSuggesterOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SpawnSuggesterOutput {
    pub suggestions: Vec<SpawnSuggestion>,
    pub summary: SpawnSummary,
}

/// UIHeddleSegment
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIHeddleSegment {
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
}

impl Default for UIHeddleSegment {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            subject: Default::default(),
        }
    }
}

/// CognitiveOptics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CognitiveOptics {
    pub albedo: NormalizedFloat,
    pub emissivity: NormalizedFloat,
    pub occlusion: NormalizedFloat,
    pub roughness: NormalizedFloat,
}

/// InternalStateType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum InternalStateType {
    #[serde(rename = "emotional_shift")]
    EmotionalShift,
    #[serde(rename = "realization")]
    Realization,
    #[serde(rename = "reflection")]
    Reflection,
    #[serde(rename = "observation")]
    Observation,
    #[serde(rename = "reaction")]
    Reaction,
}

/// DbComponentTable
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum DbComponentTable {
    FieldExcitations,
    QuantumStates,
    Content,
    CognitiveOptics,
    RelationalDynamics,
    BondPhysics,
    TaskDynamics,
}

/// ChannelType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ChannelType {
    #[serde(rename = "personal")]
    Personal,
    #[serde(rename = "family")]
    Family,
    #[serde(rename = "shared")]
    Shared,
}

/// LlmRequestDebug
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct LlmRequestDebug {
    pub system_prompt: String,
    pub user_prompt: String,
}

/// CommandAnalysis
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CommandAnalysis {
    pub command_type: CommandType,
    pub is_destructive: bool,
    pub needs_confirmation: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<serde_json::Value>,
}

impl Default for CommandAnalysis {
    fn default() -> Self {
        Self {
            command_type: CommandType.schema.json::default(),
            is_destructive: false,
            needs_confirmation: false,
            parameters: serde_json::Value::Null,
            target: Default::default(),
        }
    }
}

/// EmotionalState
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EmotionalState {
    pub arousal: SignedNormalizedFloat,
    pub dominance: SignedNormalizedFloat,
    pub valence: SignedNormalizedFloat,
}

/// RawMessageIntent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RawMessageIntent {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f64>,
    pub intent: MessageIntent,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_target: Option<QueryTarget>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_type: Option<QueryType>,
}

impl Default for RawMessageIntent {
    fn default() -> Self {
        Self {
            confidence: 1,
            intent: ../primitives/MessageIntent.schema.json::default(),
            query_target: ../primitives/QueryTarget.schema.json::default(),
            query_type: ../primitives/QueryType.schema.json::default(),
        }
    }
}

/// BindingEvidenceType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum BindingEvidenceType {
    linguistic_marker,
    temporal_proximity,
    semantic_similarity,
    co_reference,
    emotional_similarity,
    narrative_continuity,
    explicit_statement,
    contextual_inference,
}

/// BondChanges
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BondChanges {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_relationship_type: Option<RelationshipType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strength_delta: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trust_delta: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valence_delta: Option<serde_json::Value>,
}

impl Default for BondChanges {
    fn default() -> Self {
        Self {
            new_relationship_type: ../primitives/RelationshipType.schema.json::default(),
            strength_delta: Default::default(),
            trust_delta: Default::default(),
            valence_delta: Default::default(),
        }
    }
}

/// BoundingBox
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BoundingBox {
    pub height: f64,
    pub width: f64,
    pub x: f64,
    pub y: f64,
}

/// ExecutionOrder
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecutionOrder {
    sequential,
    parallel,
    conditional,
    fallback,
}

/// PipelineTrigger
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PipelineTrigger {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i64>,
    pub trigger_type: TriggerType,
    pub value: String,
}

impl Default for PipelineTrigger {
    fn default() -> Self {
        Self {
            priority: 0,
            trigger_type: TriggerType.schema.json::default(),
            value: "".to_string(),
        }
    }
}

/// MagicLinkRequestOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLinkRequestOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dev_token: Option<serde_json::Value>,
    pub email: String,
    pub expires_at: Timestamp,
    pub success: bool,
}

/// CreateFamilyFlowInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateFamilyFlowInput {
    pub family_name: String,
    pub request_id: String,
    pub user_id: UserId,
}

/// ClassifierInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassifierInput {
    pub request_id: String,
    pub state: serde_json::Value,
    pub text: String,
}

/// QueryAnalysis
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QueryAnalysis {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filters: Option<Vec<QueryFilter>>,
    pub query_type: QueryType,
    pub search_terms: Vec<String>,
    pub target: QueryTarget,
}

impl Default for QueryAnalysis {
    fn default() -> Self {
        Self {
            filters: vec![],
            query_type: ../primitives/QueryType.schema.json::default(),
            search_terms: vec![],
            target: ../primitives/QueryTarget.schema.json::default(),
        }
    }
}

/// ThreadHintOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadHintOutput {
    pub detected_threads: Vec<DetectedThread>,
    pub hints: ThreadHintValues,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggested_threads: Option<Vec<SuggestedThread>>,
}

impl Default for ThreadHintOutput {
    fn default() -> Self {
        Self {
            detected_threads: vec![],
            hints: ThreadHintValues.schema.json::default(),
            suggested_threads: vec![],
        }
    }
}

/// ActionsBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ActionsBlock {
    pub elements: Vec<BlockElement>,
}

/// PhysicsHintValues
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsHintValues {
    pub arousal: f64,
    pub energy: f64,
    pub epistemic: f64,
    pub significance: f64,
    pub temperature: f64,
    pub valence: f64,
}

/// ChatMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ChatMessage {
    pub content: String,
    pub role: MessageRole,
}

/// SegmentResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentResponse {
    pub content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mentions: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal: Option<serde_json::Value>,
}

impl Default for SegmentResponse {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            mentions: vec![],
            subject: Default::default(),
            temporal: Default::default(),
        }
    }
}

/// AsyncTaskPollResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AsyncTaskPollResponse {
    pub attempt_count: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<Timestamp>,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<serde_json::Value>,
    pub status: AsyncTaskStatus,
    pub task_id: String,
}

/// TemporalScope
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TemporalScope {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relative: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<serde_json::Value>,
}

impl Default for TemporalScope {
    fn default() -> Self {
        Self {
            end: Default::default(),
            relative: Default::default(),
            start: Default::default(),
        }
    }
}

/// MessageModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MessageModel {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_speaker: Option<serde_json::Value>,
    pub channel_id: ChannelId,
    pub content: String,
    pub created_at: String,
    pub id: MessageId,
    pub metadata: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_id: Option<MessageId>,
    pub role: MessageRole,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sender_id: Option<UserId>,
    pub thinking_steps: serde_json::Value,
    pub tool_calls: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weave_result: Option<serde_json::Value>,
}

/// InputTransform
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum InputTransform {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
}

/// BindingEvidence
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingEvidence {
    pub evidence_type: BindingEvidenceType,
    pub explanation: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub markers: Option<Vec<String>>,
    pub trigger_text: String,
}

impl Default for BindingEvidence {
    fn default() -> Self {
        Self {
            evidence_type: BindingEvidenceType.schema.json::default(),
            explanation: "".to_string(),
            markers: vec![],
            trigger_text: "".to_string(),
        }
    }
}

/// QueueMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QueueMeta {
    #[serde(rename = "$schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_schema: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub title: String,
    #[serde(rename = "x-familiar-concurrency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_concurrency: Option<i64>,
    #[serde(rename = "x-familiar-consumers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_consumers: Option<Vec<serde_json::Value>>,
    #[serde(rename = "x-familiar-dlq")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_dlq: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-kind")]
    pub x_familiar_kind: String,
    #[serde(rename = "x-familiar-producers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_producers: Option<Vec<serde_json::Value>>,
    #[serde(rename = "x-familiar-queue-type")]
    pub x_familiar_queue_type: String,
    #[serde(rename = "x-familiar-resource-class")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_resource_class: Option<String>,
    #[serde(rename = "x-familiar-retention")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_retention: Option<String>,
    #[serde(rename = "x-familiar-visibility-timeout")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_visibility_timeout: Option<String>,
}

impl Default for QueueMeta {
    fn default() -> Self {
        Self {
            schema_schema: "".to_string(),
            description: "".to_string(),
            title: "".to_string(),
            x_familiar_concurrency: 10,
            x_familiar_consumers: vec![],
            x_familiar_dlq: serde_json::Value::Null,
            x_familiar_kind: "".to_string(),
            x_familiar_producers: vec![],
            x_familiar_queue_type: "".to_string(),
            x_familiar_resource_class: "".to_string(),
            x_familiar_retention: "".to_string(),
            x_familiar_visibility_timeout: "".to_string(),
        }
    }
}

/// PlainTextInputElement
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PlainTextInputElement {
    pub action_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub initial_value: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub multiline: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub placeholder: Option<PlainTextObject>,
}

impl Default for PlainTextInputElement {
    fn default() -> Self {
        Self {
            action_id: "".to_string(),
            initial_value: Default::default(),
            multiline: false,
            placeholder: ../primitives/PlainTextObject.schema.json::default(),
        }
    }
}

/// PurposeClassifierInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PurposeClassifierInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<PurposeContext>,
    pub segment: Segment,
}

impl Default for PurposeClassifierInput {
    fn default() -> Self {
        Self {
            context: PurposeContext.schema.json::default(),
            segment: ../primitives/Segment.schema.json::default(),
        }
    }
}

/// AuthResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AuthResponse {
    pub is_new_user: bool,
    pub needs_family: bool,
    pub session: SessionCreated,
    pub user: User,
}

/// PersistenceMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PersistenceMeta {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub indexes: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_key: Option<String>,
    pub profile: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_key: Option<String>,
    pub table: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uniques: Option<Vec<Vec<String>>>,
}

impl Default for PersistenceMeta {
    fn default() -> Self {
        Self {
            indexes: vec![],
            partition_key: "".to_string(),
            primary_key: "id".to_string(),
            profile: "".to_string(),
            sort_key: "".to_string(),
            table: "".to_string(),
            uniques: vec![],
        }
    }
}

/// ButtonElement
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ButtonElement {
    pub action_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub style: Option<ButtonStyle>,
    pub text: PlainTextObject,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}

/// SpawnHints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SpawnHints {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binding: Option<BindingHints>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bond: Option<BondHints>,
    pub physics: PhysicsHints,
    pub thread: ThreadHints,
}

impl Default for SpawnHints {
    fn default() -> Self {
        Self {
            binding: BindingHints.schema.json::default(),
            bond: BondHints.schema.json::default(),
            physics: PhysicsHints.schema.json::default(),
            thread: ThreadHints.schema.json::default(),
        }
    }
}

/// CreateUserInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateUserInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    pub email: Email,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password_hash: Option<PasswordHash>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_tenant_id: Option<serde_json::Value>,
}

impl Default for CreateUserInput {
    fn default() -> Self {
        Self {
            avatar_url: Default::default(),
            email: ../primitives/Email.schema.json::default(),
            name: "".to_string(),
            password_hash: ../primitives/PasswordHash.schema.json::default(),
            primary_tenant_id: Default::default(),
        }
    }
}

/// ThreadCategory
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ThreadCategory {
    people,
    places,
    activities,
    projects,
    topics,
    events,
    groups,
    health,
    finance,
    relationships,
}

/// QueryTarget
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QueryTarget {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_types: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keywords: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal_scope: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread_hints: Option<Vec<String>>,
}

impl Default for QueryTarget {
    fn default() -> Self {
        Self {
            entity_types: vec![],
            keywords: vec![],
            temporal_scope: Default::default(),
            thread_hints: vec![],
        }
    }
}

/// ParameterConstraints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ParameterConstraints {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_values: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<serde_json::Value>,
}

impl Default for ParameterConstraints {
    fn default() -> Self {
        Self {
            allowed_values: Default::default(),
            max: Default::default(),
            min: Default::default(),
            pattern: Default::default(),
        }
    }
}

/// FamiliarEntity
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FamiliarEntity {
    pub content: String,
    pub created_at: String,
    pub entity_type: FamiliarEntityType,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics: Option<EntityPhysics>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qdrant_collection: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qdrant_point_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_at: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_by: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_channel_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_message_id: Option<serde_json::Value>,
    pub status: EntityStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
    pub tenant_id: TenantId,
    pub updated_at: String,
}

impl Default for FamiliarEntity {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            created_at: "".to_string(),
            entity_type: ../entities/FamiliarEntityType.schema.json::default(),
            id: "".to_string(),
            metadata: Default::default(),
            physics: EntityPhysics.schema.json::default(),
            qdrant_collection: Default::default(),
            qdrant_point_id: Default::default(),
            reviewed_at: Default::default(),
            reviewed_by: Default::default(),
            source_channel_id: Default::default(),
            source_message_id: Default::default(),
            status: ../entities/EntityStatus.schema.json::default(),
            subject: Default::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            updated_at: "".to_string(),
        }
    }
}

/// ContentPayload
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContentPayload {
    pub metadata: serde_json::Value,
    pub text: String,
}

/// EntityPatterns
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityPatterns {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub distribution: Option<serde_json::Value>,
    pub primary_type: EntityType,
}

impl Default for EntityPatterns {
    fn default() -> Self {
        Self {
            distribution: serde_json::Value::Null,
            primary_type: ../primitives/EntityType.schema.json::default(),
        }
    }
}

/// DbEntityTable
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum DbEntityTable {
    Pulse,
    Thread,
    Bond,
    Moment,
    Intent,
    Focus,
    Motif,
    Filament,
}

/// PhysicsOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub done: Option<bool>,
    pub operation: String,
    pub response_message: String,
    pub result: serde_json::Value,
    pub state: serde_json::Value,
}

impl Default for PhysicsOutput {
    fn default() -> Self {
        Self {
            done: true,
            operation: "".to_string(),
            response_message: "".to_string(),
            result: Default::default(),
            state: Default::default(),
        }
    }
}

/// TenantModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TenantModel {
    pub created_at: String,
    pub id: TenantId,
    pub name: String,
    pub settings: serde_json::Value,
    pub updated_at: String,
}

/// ListChannelsOptions
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ListChannelsOptions {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_type: Option<ChannelType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner_id: Option<serde_json::Value>,
}

impl Default for ListChannelsOptions {
    fn default() -> Self {
        Self {
            channel_type: ../entities/ChannelType.schema.json::default(),
            owner_id: Default::default(),
        }
    }
}

/// AudioSegmentFeatures
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AudioSegmentFeatures {
    pub audio_features: AudioFeatures,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub speaker_id: Option<serde_json::Value>,
    pub transcript: String,
}

impl Default for AudioSegmentFeatures {
    fn default() -> Self {
        Self {
            audio_features: AudioFeatures.schema.json::default(),
            speaker_id: Default::default(),
            transcript: "".to_string(),
        }
    }
}

/// ContextElement
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum ContextElement {
    Variant0,
    Variant1,
    Variant2,
}

/// PhysicsInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PhysicsInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_position: Option<VAEPosition>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_type: Option<serde_json::Value>,
    pub operation: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics_hint: Option<PhysicsHint>,
    pub request_id: String,
    pub state: serde_json::Value,
}

impl Default for PhysicsInput {
    fn default() -> Self {
        Self {
            current_position: ../tools/VAEPosition.schema.json::default(),
            entity_type: Default::default(),
            operation: "".to_string(),
            physics_hint: ../components/PhysicsHint.schema.json::default(),
            request_id: "".to_string(),
            state: Default::default(),
        }
    }
}

/// AgenticFlowResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AgenticFlowResponse {
    pub agent: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub has_more_tasks: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub heddle_result: Option<UIHeddleResult>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_request: Option<serde_json::Value>,
    pub request_id: String,
    pub response: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking_steps: Option<Vec<UIThinkingStep>>,
    pub thread_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<UIToolCall>>,
}

impl Default for AgenticFlowResponse {
    fn default() -> Self {
        Self {
            agent: "".to_string(),
            has_more_tasks: false,
            heddle_result: UIHeddleResult.schema.json::default(),
            next_request: Default::default(),
            request_id: "".to_string(),
            response: "".to_string(),
            state: Default::default(),
            thinking_steps: vec![],
            thread_id: "".to_string(),
            tool_calls: vec![],
        }
    }
}

/// RAGInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RAGInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filters: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<i64>,
    pub query: String,
    pub request_id: String,
    pub state: serde_json::Value,
}

impl Default for RAGInput {
    fn default() -> Self {
        Self {
            filters: Default::default(),
            limit: 10,
            query: "".to_string(),
            request_id: "".to_string(),
            state: Default::default(),
        }
    }
}

/// ConversationHistoryItem
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConversationHistoryItem {
    pub content: String,
    pub role: MemberRole,
}

/// SuccessResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SuccessResult {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<serde_json::Value>,
    pub success: bool,
}

/// ImageBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ImageBlock {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alt_text: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analyze: Option<bool>,
    pub source: String,
}

impl Default for ImageBlock {
    fn default() -> Self {
        Self {
            alt_text: Default::default(),
            analyze: true,
            source: "".to_string(),
        }
    }
}

/// BlockMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BlockMessage {
    pub blocks: Vec<Block>,
}

/// ToolExecutionMetadata
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolExecutionMetadata {
    pub duration_ms: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<serde_json::Value>,
    pub started_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_usage: Option<TokenUsage>,
    pub tool_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_id: Option<serde_json::Value>,
}

impl Default for ToolExecutionMetadata {
    fn default() -> Self {
        Self {
            duration_ms: 0,
            model: Default::default(),
            started_at: "".to_string(),
            token_usage: ../primitives/TokenUsage.schema.json::default(),
            tool_name: "".to_string(),
            trace_id: Default::default(),
        }
    }
}

/// CourseStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum CourseStatus {
    #[serde(rename = "received")]
    Received,
    #[serde(rename = "segmenting")]
    Segmenting,
    #[serde(rename = "processing")]
    Processing,
    #[serde(rename = "responding")]
    Responding,
    #[serde(rename = "complete")]
    Complete,
    #[serde(rename = "failed")]
    Failed,
}

/// FieldExcitationModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FieldExcitationModel {
    pub amplitude: f64,
    pub energy: f64,
    pub entity_id: EntityId,
    pub pos_arousal: i64,
    pub pos_epistemic: i64,
    pub pos_valence: i64,
    pub temperature: f64,
    pub time: String,
    pub vel_arousal: i64,
    pub vel_epistemic: i64,
    pub vel_valence: i64,
}

/// AuthSession
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AuthSession {
    pub created_at: String,
    pub expires_at: String,
    pub id: SessionId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    pub token_hash: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
    pub user_id: UserId,
}

impl Default for AuthSession {
    fn default() -> Self {
        Self {
            created_at: "".to_string(),
            expires_at: "".to_string(),
            id: ../primitives/SessionId.schema.json::default(),
            ip_address: Default::default(),
            token_hash: "".to_string(),
            user_agent: Default::default(),
            user_id: ../primitives/UserId.schema.json::default(),
        }
    }
}

/// Payload
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum Payload {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
    Variant6,
    Variant7,
    Variant8,
    Variant9,
    Variant10,
    Variant11,
    Variant12,
    Variant13,
    Variant14,
    Variant15,
    Variant16,
    Variant17,
    Variant18,
}

/// DeletionStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum DeletionStatus {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "cancelled")]
    Cancelled,
    #[serde(rename = "processing")]
    Processing,
    #[serde(rename = "completed")]
    Completed,
}

/// UIChannelMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIChannelMessage {
    pub content: String,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_active: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_expanded: Option<bool>,
    pub thread: Vec<UIThreadItem>,
    pub timestamp: String,
}

impl Default for UIChannelMessage {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            id: "".to_string(),
            is_active: false,
            is_expanded: false,
            thread: vec![],
            timestamp: "".to_string(),
        }
    }
}

/// AnthropicClaudeResource
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AnthropicClaudeResource(pub serde_json::Value);

/// EmotionalTone
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EmotionalTone {
    pub arousal: f64,
    pub confidence: f64,
    pub primary: String,
    pub valence: f64,
}

/// ContextStrategy
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ContextStrategy {
    full_context,
    filtered_context,
    accumulating_context,
    isolated_context,
}

/// BindingType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum BindingType {
    causal,
    temporal,
    associative,
    compositional,
    contrastive,
    analogical,
    enabling,
    thematic,
}

/// Model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Model {
    pub channel_type: ChannelType,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<serde_json::Value>,
    pub id: String,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner_id: Option<serde_json::Value>,
    pub settings: serde_json::Value,
    pub tenant_id: TenantId,
    pub updated_at: String,
}

/// HeddleEntityType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum HeddleEntityType {
    MOMENT,
    INTENT,
    THREAD,
    BOND,
    MOTIF,
    FILAMENT,
    FOCUS,
    PULSE,
}

/// StepCondition
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct StepCondition {
    pub condition_type: ConditionType,
    pub operator: ConditionOperator,
    pub path: String,
    pub source_step: String,
    pub value: serde_json::Value,
}

/// ThreadReference
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadReference {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    pub id: String,
    pub name: String,
    pub thread_type: String,
}

impl Default for ThreadReference {
    fn default() -> Self {
        Self {
            aliases: vec![],
            id: "".to_string(),
            name: "".to_string(),
            thread_type: "".to_string(),
        }
    }
}

/// AgentSpeaker
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum AgentSpeaker {
    concierge,
    classifier,
    physics,
    rag,
    memory,
    task_executor,
}

/// UIChannel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIChannel {
    pub created_at: String,
    pub id: String,
    pub messages: Vec<UIChannelMessage>,
    pub name: String,
    pub updated_at: String,
}

/// SegmentBoundaries
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentBoundaries {
    pub end: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub speaker_id: Option<serde_json::Value>,
    pub start: i64,
}

impl Default for SegmentBoundaries {
    fn default() -> Self {
        Self {
            end: 0,
            speaker_id: Default::default(),
            start: 0,
        }
    }
}

/// Modality
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum Modality {
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "audio")]
    Audio,
    #[serde(rename = "vision")]
    Vision,
    #[serde(rename = "video")]
    Video,
}

/// GoogleContent
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct GoogleContent {
    pub parts: Vec<GooglePart>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<serde_json::Value>,
}

/// LogLevel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum LogLevel {
    #[serde(rename = "debug")]
    Debug,
    #[serde(rename = "info")]
    Info,
    #[serde(rename = "warning")]
    Warning,
    #[serde(rename = "error")]
    Error,
}

/// MessageRole
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MessageRole {
    #[serde(rename = "system")]
    System,
    #[serde(rename = "user")]
    User,
    #[serde(rename = "assistant")]
    Assistant,
}

/// ToolCallResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolCallResult {
    pub call_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<serde_json::Value>,
    pub success: bool,
}

impl Default for ToolCallResult {
    fn default() -> Self {
        Self {
            call_id: "".to_string(),
            error: Default::default(),
            result: Default::default(),
            success: false,
        }
    }
}

/// CognitiveDimensions
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CognitiveDimensions {
    pub agreeableness: NormalizedFloat,
    pub conscientiousness: NormalizedFloat,
    pub extraversion: NormalizedFloat,
    pub neuroticism: NormalizedFloat,
    pub openness: NormalizedFloat,
}

/// ConversationMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConversationMessage {
    pub content: String,
    pub role: String,
}

/// NodeMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct NodeMeta {
    #[serde(rename = "$schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema_schema: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub title: String,
    #[serde(rename = "x-familiar-components")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_components: Option<Vec<serde_json::Value>>,
    #[serde(rename = "x-familiar-concurrency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_concurrency: Option<i64>,
    #[serde(rename = "x-familiar-kind")]
    pub x_familiar_kind: String,
    #[serde(rename = "x-familiar-memory")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_memory: Option<String>,
    #[serde(rename = "x-familiar-queue")]
    pub x_familiar_queue: String,
    #[serde(rename = "x-familiar-resource-class")]
    pub x_familiar_resource_class: String,
    #[serde(rename = "x-familiar-resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_resources: Option<Vec<serde_json::Value>>,
    #[serde(rename = "x-familiar-systems")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_systems: Option<Vec<serde_json::Value>>,
}

impl Default for NodeMeta {
    fn default() -> Self {
        Self {
            schema_schema: "".to_string(),
            description: "".to_string(),
            title: "".to_string(),
            x_familiar_components: vec![],
            x_familiar_concurrency: 10,
            x_familiar_kind: "".to_string(),
            x_familiar_memory: "".to_string(),
            x_familiar_queue: "".to_string(),
            x_familiar_resource_class: "".to_string(),
            x_familiar_resources: vec![],
            x_familiar_systems: vec![],
        }
    }
}

/// ConsentRecordModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConsentRecordModel {
    pub consent_type: ConsentType,
    pub created_at: String,
    pub granted: bool,
    pub id: ConsentRecordId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
    pub user_id: UserId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<serde_json::Value>,
}

/// AudioFeatures
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AudioFeatures {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pitch_variance: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub speaking_rate: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub voice_emotion: Option<serde_json::Value>,
    pub volume: f64,
}

impl Default for AudioFeatures {
    fn default() -> Self {
        Self {
            pitch_variance: Default::default(),
            speaking_rate: Default::default(),
            voice_emotion: Default::default(),
            volume: 0.0,
        }
    }
}

/// PipelineType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum PipelineType {
    memory_recording,
    query,
    analysis,
    command,
    conversation,
    multi_modal,
}

/// ShuttleStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ShuttleStatus {
    pending,
    classifying,
    spawning,
    complete,
    failed,
}

/// MomentType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MomentType {
    Event,
    Realization,
    Interaction,
    Observation,
}

/// ChannelModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ChannelModel {
    pub channel_type: ChannelType,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<serde_json::Value>,
    pub id: ChannelId,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner_id: Option<UserId>,
    pub settings: serde_json::Value,
    pub tenant_id: TenantId,
    pub updated_at: String,
    pub version: i64,
}

/// JoinRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct JoinRequest {
    pub created_at: String,
    pub id: JoinRequestId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub review_note: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_at: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_by: Option<serde_json::Value>,
    pub status: JoinRequestStatus,
    pub tenant_id: TenantId,
    pub user_id: UserId,
}

impl Default for JoinRequest {
    fn default() -> Self {
        Self {
            created_at: "".to_string(),
            id: ../primitives/JoinRequestId.schema.json::default(),
            message: Default::default(),
            review_note: Default::default(),
            reviewed_at: Default::default(),
            reviewed_by: Default::default(),
            status: ../entities/JoinRequestStatus.schema.json::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
            user_id: ../primitives/UserId.schema.json::default(),
        }
    }
}

/// ThreadRelation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadRelation {
    pub relation_type: ThreadRelationType,
    pub source_id: String,
    pub strength: f64,
    pub target_id: String,
}

/// TextBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TextBlock {
    pub content: String,
}

/// CreateCodeInviteInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CreateCodeInviteInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_in_days: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_uses: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<InviteRole>,
    pub tenant_id: TenantId,
}

impl Default for CreateCodeInviteInput {
    fn default() -> Self {
        Self {
            expires_in_days: Default::default(),
            max_uses: 1,
            role: InviteRole.schema.json::default(),
            tenant_id: ../primitives/TenantId.schema.json::default(),
        }
    }
}

/// GooglePart
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct GooglePart {
    pub text: String,
}

/// ErrorStrategy
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ErrorStrategy {
    fail_fast,
    continue_on_error,
    retry_on_error,
    use_fallback,
}

/// ConciergeOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConciergeOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub done: Option<bool>,
    pub response: AgentResponse,
    pub state: serde_json::Value,
}

impl Default for ConciergeOutput {
    fn default() -> Self {
        Self {
            done: false,
            response: AgentResponse.schema.json::default(),
            state: Default::default(),
        }
    }
}

/// ReviewJoinRequestInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ReviewJoinRequestInput {
    pub approved: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<serde_json::Value>,
}

impl Default for ReviewJoinRequestInput {
    fn default() -> Self {
        Self {
            approved: false,
            note: Default::default(),
        }
    }
}

/// TraceStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TraceStatus {
    started,
    in_progress,
    completed,
    failed,
    cancelled,
}

/// VerbCategory
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum VerbCategory {
    action,
    state,
    evaluative,
    relational,
    habitual,
    intentional,
}

/// EntityStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum EntityStatus {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "approved")]
    Approved,
    #[serde(rename = "rejected")]
    Rejected,
    #[serde(rename = "auto_spawned")]
    AutoSpawned,
}

/// DetectionMethod
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum DetectionMethod {
    exact_match,
    alias_match,
    fuzzy_match,
    pronoun_resolution,
    keyword_match,
    semantic_match,
}

/// SystemManifest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SystemManifest {
    pub description: String,
    pub domain: SystemDomain,
    pub id: String,
    pub reads: Vec<String>,
    pub trigger: SystemTrigger,
    pub writes: Vec<String>,
}

/// RelationshipType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum RelationshipType {
    #[serde(rename = "family")]
    Family,
    #[serde(rename = "friend")]
    Friend,
    #[serde(rename = "close_friend")]
    CloseFriend,
    #[serde(rename = "best_friend")]
    BestFriend,
    #[serde(rename = "romantic")]
    Romantic,
    #[serde(rename = "ex_romantic")]
    ExRomantic,
    #[serde(rename = "spouse")]
    Spouse,
    #[serde(rename = "parent")]
    Parent,
    #[serde(rename = "child")]
    Child,
    #[serde(rename = "sibling")]
    Sibling,
    #[serde(rename = "colleague")]
    Colleague,
    #[serde(rename = "manager")]
    Manager,
    #[serde(rename = "direct_report")]
    DirectReport,
    #[serde(rename = "mentor")]
    Mentor,
    #[serde(rename = "mentee")]
    Mentee,
    #[serde(rename = "client")]
    Client,
    #[serde(rename = "vendor")]
    Vendor,
    #[serde(rename = "partner")]
    Partner,
    #[serde(rename = "acquaintance")]
    Acquaintance,
    #[serde(rename = "neighbor")]
    Neighbor,
    #[serde(rename = "classmate")]
    Classmate,
    #[serde(rename = "teammate")]
    Teammate,
    #[serde(rename = "adversary")]
    Adversary,
    #[serde(rename = "rival")]
    Rival,
    #[serde(rename = "service_provider")]
    ServiceProvider,
    #[serde(rename = "other")]
    Other,
}

/// SegmentationContext
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SegmentationContext {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_speaker: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub known_entities: Option<Vec<KnownEntity>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_segments: Option<Vec<Segment>>,
    pub tenant_id: String,
}

impl Default for SegmentationContext {
    fn default() -> Self {
        Self {
            current_speaker: Default::default(),
            known_entities: vec![],
            previous_segments: vec![],
            tenant_id: "".to_string(),
        }
    }
}

/// ContentPayloadModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContentPayloadModel {
    pub entity_id: EntityId,
    pub metadata: serde_json::Value,
    pub text_content: String,
}

/// LoginRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct LoginRequest {
    pub email: Email,
    pub password: String,
}

/// BindingPattern
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingPattern {
    pub binding_type: BindingType,
    pub confidence_boost: f64,
    pub name: String,
    pub pattern: String,
}

/// BindingGraphUpdate
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingGraphUpdate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binding: Option<BindingCharacteristics>,
    pub source_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_id: Option<serde_json::Value>,
    pub update_type: GraphUpdateType,
}

impl Default for BindingGraphUpdate {
    fn default() -> Self {
        Self {
            binding: BindingCharacteristics.schema.json::default(),
            source_id: "".to_string(),
            target_id: Default::default(),
            update_type: GraphUpdateType.schema.json::default(),
        }
    }
}

/// DetectedPerson
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedPerson {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bounding_box: Option<BoundingBox>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub emotion: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub face_id: Option<serde_json::Value>,
}

impl Default for DetectedPerson {
    fn default() -> Self {
        Self {
            bounding_box: BoundingBox.schema.json::default(),
            emotion: Default::default(),
            face_id: Default::default(),
        }
    }
}

/// BindingHints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct BindingHints {
    pub binding_type: BindingType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<serde_json::Value>,
    pub directionality: Directionality,
    pub source: EntityReference,
    pub strength: f64,
    pub target: EntityReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporal: Option<TemporalBinding>,
}

impl Default for BindingHints {
    fn default() -> Self {
        Self {
            binding_type: ../primitives/BindingType.schema.json::default(),
            context: Default::default(),
            directionality: ../primitives/Directionality.schema.json::default(),
            source: EntityReference.schema.json::default(),
            strength: 0.0,
            target: EntityReference.schema.json::default(),
            temporal: TemporalBinding.schema.json::default(),
        }
    }
}

/// UserPurposePatterns
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UserPurposePatterns {
    pub primary_purpose: ToolPurpose,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub purpose_distribution: Option<serde_json::Value>,
}

impl Default for UserPurposePatterns {
    fn default() -> Self {
        Self {
            primary_purpose: ../primitives/ToolPurpose.schema.json::default(),
            purpose_distribution: serde_json::Value::Null,
        }
    }
}

/// ClassificationPhysics
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassificationPhysics {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arousal: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub clarity: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub significance: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valence: Option<serde_json::Value>,
}

impl Default for ClassificationPhysics {
    fn default() -> Self {
        Self {
            arousal: Default::default(),
            clarity: Default::default(),
            significance: Default::default(),
            valence: Default::default(),
        }
    }
}

/// ConciergeInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ConciergeInput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_first_message: Option<bool>,
    pub request_id: String,
    pub state: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_message: Option<serde_json::Value>,
}

impl Default for ConciergeInput {
    fn default() -> Self {
        Self {
            is_first_message: false,
            request_id: "".to_string(),
            state: Default::default(),
            user_message: Default::default(),
        }
    }
}

/// ToolCallStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ToolCallStatus {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "complete")]
    Complete,
    #[serde(rename = "error")]
    Error,
}

/// CodegenMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CodegenMeta {
    #[serde(rename = "x-familiar-rust-default")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_default: Option<String>,
    #[serde(rename = "x-familiar-rust-derive-add")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_derive_add: Option<Vec<String>>,
    #[serde(rename = "x-familiar-rust-derive-exclude")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_derive_exclude: Option<Vec<String>>,
    #[serde(rename = "x-familiar-rust-derive-policy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_derive_policy: Option<String>,
    #[serde(rename = "x-familiar-rust-derives")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_derives: Option<Vec<String>>,
    #[serde(rename = "x-familiar-rust-impl-ids")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_impl_ids: Option<Vec<String>>,
    #[serde(rename = "x-familiar-rust-recursion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_recursion: Option<serde_json::Value>,
    #[serde(rename = "x-familiar-rust-serde")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_rust_serde: Option<serde_json::Value>,
}

impl Default for CodegenMeta {
    fn default() -> Self {
        Self {
            x_familiar_rust_default: "derived".to_string(),
            x_familiar_rust_derive_add: vec![],
            x_familiar_rust_derive_exclude: vec![],
            x_familiar_rust_derive_policy: "strict".to_string(),
            x_familiar_rust_derives: vec![],
            x_familiar_rust_impl_ids: vec![],
            x_familiar_rust_recursion: serde_json::Value::Null,
            x_familiar_rust_serde: serde_json::Value::Null,
        }
    }
}

/// BlockElement
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum BlockElement {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
}

/// AsyncTask
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AsyncTask {
    pub attempt_count: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<Timestamp>,
    pub correlation_id: String,
    pub created_at: Timestamp,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<serde_json::Value>,
    pub id: String,
    pub input: serde_json::Value,
    pub max_attempts: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_retry_at: Option<Timestamp>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<Timestamp>,
    pub status: AsyncTaskStatus,
    pub task_type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tenant_id: Option<TenantId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<UserId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub windmill_flow_path: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub windmill_job_id: Option<serde_json::Value>,
}

/// WorkerQueueQueue
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct WorkerQueueQueue(pub serde_json::Value);

/// MediaRef
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MediaRef {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket_key: Option<serde_json::Value>,
    pub id: String,
    pub media_type: MediaType,
    pub metadata: serde_json::Value,
    pub normalized_text: String,
}

/// CourseSummary
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CourseSummary {
    pub id: String,
    pub message_count: i64,
    pub preview: String,
    pub status: CourseStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<serde_json::Value>,
    pub updated_at: Timestamp,
}

/// Segment
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Segment {
    pub boundaries: SegmentBoundaries,
    pub confidence: f64,
    pub content: String,
    pub features: SegmentFeatures,
    pub id: String,
    pub index: i64,
    pub modality: Modality,
}

/// EcsCodegenMeta
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EcsCodegenMeta {
    #[serde(rename = "x-familiar-casing")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_casing: Option<Casing>,
    #[serde(rename = "x-familiar-content")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_content: Option<String>,
    #[serde(rename = "x-familiar-default")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_default: Option<bool>,
    #[serde(rename = "x-familiar-discriminator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_discriminator: Option<String>,
    #[serde(rename = "x-familiar-enum-repr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_enum_repr: Option<EnumRepr>,
    #[serde(rename = "x-familiar-flatten")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_flatten: Option<bool>,
    #[serde(rename = "x-familiar-newtype")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_newtype: Option<bool>,
    #[serde(rename = "x-familiar-skip-none")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_skip_none: Option<bool>,
    #[serde(rename = "x-familiar-variants")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x_familiar_variants: Option<serde_json::Value>,
}

impl Default for EcsCodegenMeta {
    fn default() -> Self {
        Self {
            x_familiar_casing: Casing.schema.json::default(),
            x_familiar_content: "".to_string(),
            x_familiar_default: false,
            x_familiar_discriminator: "".to_string(),
            x_familiar_enum_repr: EnumRepr.schema.json::default(),
            x_familiar_flatten: false,
            x_familiar_newtype: false,
            x_familiar_skip_none: false,
            x_familiar_variants: serde_json::Value::Null,
        }
    }
}

/// DocumentBlock
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DocumentBlock {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filename: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mime_type: Option<serde_json::Value>,
    pub source: String,
}

/// User
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct User {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<serde_json::Value>,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deletion_requested_at: Option<serde_json::Value>,
    pub email: Email,
    pub email_verified: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gdpr_consents: Option<serde_json::Value>,
    pub id: UserId,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_tenant_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings: Option<serde_json::Value>,
    pub updated_at: String,
}

impl Default for User {
    fn default() -> Self {
        Self {
            avatar_url: Default::default(),
            created_at: "".to_string(),
            deletion_requested_at: Default::default(),
            email: ../primitives/Email.schema.json::default(),
            email_verified: false,
            gdpr_consents: Default::default(),
            id: ../primitives/UserId.schema.json::default(),
            name: "".to_string(),
            primary_tenant_id: Default::default(),
            settings: Default::default(),
            updated_at: "".to_string(),
        }
    }
}

/// EntityRegistryModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityRegistryModel {
    pub created_at: String,
    pub entity_type: String,
    pub id: EntityId,
    pub tenant_id: TenantId,
}

/// MagicLinkRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLinkRequest {
    pub email: Email,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<InviteCode>,
}

/// InvitationInfo
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct InvitationInfo {
    pub id: InvitationId,
    pub is_valid: bool,
    pub role: InviteRole,
    pub tenant_id: TenantId,
    pub tenant_name: String,
}

/// RAGResult
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RAGResult {
    pub content: String,
    pub entity_type: String,
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub score: f64,
}

impl Default for RAGResult {
    fn default() -> Self {
        Self {
            content: "".to_string(),
            entity_type: "".to_string(),
            id: "".to_string(),
            metadata: Default::default(),
            score: 0.0,
        }
    }
}

/// PurposeClassifierOutput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct PurposeClassifierOutput {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub command_analysis: Option<CommandAnalysis>,
    pub pipeline: PurposePipeline,
    pub primary: ClassifiedPurpose,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_analysis: Option<QueryAnalysis>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary: Option<Vec<ClassifiedPurpose>>,
}

impl Default for PurposeClassifierOutput {
    fn default() -> Self {
        Self {
            command_analysis: CommandAnalysis.schema.json::default(),
            pipeline: PurposePipeline.schema.json::default(),
            primary: ClassifiedPurpose.schema.json::default(),
            query_analysis: QueryAnalysis.schema.json::default(),
            secondary: vec![],
        }
    }
}

/// ClassifiedPurpose
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ClassifiedPurpose {
    pub confidence: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evidence: Option<Vec<String>>,
    pub purpose: ToolPurpose,
}

impl Default for ClassifiedPurpose {
    fn default() -> Self {
        Self {
            confidence: 0.0,
            evidence: vec![],
            purpose: ../primitives/ToolPurpose.schema.json::default(),
        }
    }
}

/// ThreadHints
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadHints {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub create_if_missing: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub keywords: Option<Vec<String>>,
    pub primary_subject: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub related_threads: Option<Vec<ThreadReference>>,
    pub thread_role: ThreadRole,
}

impl Default for ThreadHints {
    fn default() -> Self {
        Self {
            create_if_missing: false,
            keywords: vec![],
            primary_subject: "".to_string(),
            related_threads: vec![],
            thread_role: ../primitives/ThreadRole.schema.json::default(),
        }
    }
}

/// SignupRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SignupRequest {
    pub accept_privacy: bool,
    pub accept_terms: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consents: Option<SignupConsents>,
    pub email: Email,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<InviteCode>,
    pub name: String,
    pub password: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_context: Option<RequestContext>,
}

/// ThreadHintInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ThreadHintInput {
    pub entity_type: EntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub known_threads: Option<Vec<ThreadReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recent_threads: Option<Vec<RecentThread>>,
    pub segment: Segment,
}

impl Default for ThreadHintInput {
    fn default() -> Self {
        Self {
            entity_type: ../primitives/EntityType.schema.json::default(),
            known_threads: vec![],
            recent_threads: vec![],
            segment: ../primitives/Segment.schema.json::default(),
        }
    }
}

/// RecentThread
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RecentThread {
    pub mention_count: i64,
    pub recency: i64,
    pub thread: ThreadReference,
}

/// ToolPurpose
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ToolPurpose {
    LOG,
    QUERY,
    INFER,
    REFERENCE,
    REFLECT,
    COMMAND,
    SOCIAL,
    CONTINUATION,
    CORRECTION,
}

/// AccordionState
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum AccordionState {
    #[serde(rename = "collapsed")]
    Collapsed,
    #[serde(rename = "expanded")]
    Expanded,
}

/// MessageTokenInfo
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MessageTokenInfo {
    pub id: String,
    pub included: bool,
    pub role: MessageRole,
    pub tokens: i64,
}

/// ProducerInfo
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ProducerInfo {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub build: Option<serde_json::Value>,
    pub instance: String,
    pub service: String,
}

/// MessageStatusType
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum MessageStatusType {
    #[serde(rename = "sending")]
    Sending,
    #[serde(rename = "sent")]
    Sent,
    #[serde(rename = "delivered")]
    Delivered,
    #[serde(rename = "read")]
    Read,
    #[serde(rename = "failed")]
    Failed,
}

/// ApiError
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ApiError {
    pub code: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,
    pub message: String,
}

/// LinguisticAnalysis
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct LinguisticAnalysis {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modifiers: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub objects: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subjects: Option<Vec<String>>,
    pub verbs: Vec<IdentifiedVerb>,
}

impl Default for LinguisticAnalysis {
    fn default() -> Self {
        Self {
            modifiers: vec![],
            objects: vec![],
            subjects: vec![],
            verbs: vec![],
        }
    }
}

/// CourseResponse
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CourseResponse {
    pub course_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub debug_llm_request: Option<LlmRequestDebug>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub debug_llm_response: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entities: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_refs: Option<serde_json::Value>,
    pub message_intent: MessageIntent,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    pub original_weave: String,
    pub provider: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub segments: Option<Vec<SegmentResponse>>,
    pub shuttle_id: String,
    pub success: bool,
    pub unit_count: i64,
    pub weave_units: Vec<WeaveUnitResponse>,
}

impl Default for CourseResponse {
    fn default() -> Self {
        Self {
            course_id: "".to_string(),
            debug_llm_request: ../components/LlmRequestDebug.schema.json::default(),
            debug_llm_response: Default::default(),
            entities: Default::default(),
            error: Default::default(),
            media_refs: Default::default(),
            message_intent: ../primitives/MessageIntent.schema.json::default(),
            metadata: Default::default(),
            original_weave: "".to_string(),
            provider: "".to_string(),
            segments: vec![],
            shuttle_id: "".to_string(),
            success: false,
            unit_count: 0,
            weave_units: vec![],
        }
    }
}

/// TemporalProperties
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct TemporalProperties {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gap: Option<TimeGap>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recurring: Option<bool>,
    pub relation: TemporalRelation,
}

impl Default for TemporalProperties {
    fn default() -> Self {
        Self {
            gap: ../primitives/TimeGap.schema.json::default(),
            recurring: false,
            relation: ../primitives/TemporalRelation.schema.json::default(),
        }
    }
}

/// RecordConsentInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RecordConsentInput {
    pub consent_type: ConsentType,
    pub granted: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<serde_json::Value>,
}

impl Default for RecordConsentInput {
    fn default() -> Self {
        Self {
            consent_type: ../entities/ConsentType.schema.json::default(),
            granted: false,
            version: Default::default(),
        }
    }
}

/// ContextWindow
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ContextWindow {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub following: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preceding: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_span_hours: Option<serde_json::Value>,
}

impl Default for ContextWindow {
    fn default() -> Self {
        Self {
            following: vec![],
            preceding: vec![],
            time_span_hours: Default::default(),
        }
    }
}

/// DurationCategory
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum DurationCategory {
    #[serde(rename = "new")]
    New,
    #[serde(rename = "recent")]
    Recent,
    #[serde(rename = "established")]
    Established,
    #[serde(rename = "long_term")]
    LongTerm,
    #[serde(rename = "lifelong")]
    Lifelong,
}

/// StandardPipeline
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct StandardPipeline {
    pub chain: ToolChain,
    pub pipeline_type: PipelineType,
    pub triggers: Vec<PipelineTrigger>,
}

/// Directionality
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum Directionality {
    unidirectional,
    bidirectional,
    undirected,
}

/// ToolDefinition
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ToolDefinition {
    pub category: ToolCategory,
    pub description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub estimated_latency_ms: Option<serde_json::Value>,
    pub name: String,
    pub parallelizable: bool,
    pub parameters: Vec<ToolParameter>,
    pub version: String,
}

impl Default for ToolDefinition {
    fn default() -> Self {
        Self {
            category: ToolCategory.schema.json::default(),
            description: "".to_string(),
            estimated_latency_ms: Default::default(),
            name: "".to_string(),
            parallelizable: false,
            parameters: vec![],
            version: "".to_string(),
        }
    }
}

/// AsyncTaskStatus
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum AsyncTaskStatus {
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "queued")]
    Queued,
    #[serde(rename = "running")]
    Running,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "failed")]
    Failed,
    #[serde(rename = "cancelled")]
    Cancelled,
}

/// EntityReference
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct EntityReference {
    pub description: String,
    pub entity_type: EntityType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<serde_json::Value>,
}

impl Default for EntityReference {
    fn default() -> Self {
        Self {
            description: "".to_string(),
            entity_type: ../primitives/EntityType.schema.json::default(),
            id: Default::default(),
        }
    }
}

/// FamiliarEntityModel
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FamiliarEntityModel {
    pub content: String,
    pub created_at: String,
    pub entity_type: FamiliarEntityType,
    pub id: EntityId,
    pub metadata: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub physics: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qdrant_collection: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qdrant_point_id: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_at: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reviewed_by: Option<UserId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_channel_id: Option<ChannelId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_message_id: Option<MessageId>,
    pub status: EntityStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<serde_json::Value>,
    pub tenant_id: TenantId,
    pub updated_at: String,
}

/// WsMessage
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum WsMessage {
    Variant0,
    Variant1,
    Variant2,
    Variant3,
    Variant4,
    Variant5,
}

/// UIClassification
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UIClassification {
    pub confidence: f64,
    pub entity_type: String,
}

/// AsyncTaskCreated
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AsyncTaskCreated {
    pub correlation_id: String,
    pub poll_url: String,
    pub status: AsyncTaskStatus,
    pub task_id: String,
}

/// PurposePipeline
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum PurposePipeline {
    recording,
    retrieval,
    analysis,
    action,
    conversational,
}

/// DetectedObject
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DetectedObject {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bounding_box: Option<BoundingBox>,
    pub confidence: f64,
    pub label: String,
}

impl Default for DetectedObject {
    fn default() -> Self {
        Self {
            bounding_box: BoundingBox.schema.json::default(),
            confidence: 0.0,
            label: "".to_string(),
        }
    }
}

/// MagicLinkFlowInput
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MagicLinkFlowInput {
    pub action: MagicLinkAction,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invite_code: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<serde_json::Value>,
    pub request_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_agent: Option<serde_json::Value>,
}

/// DataExportRequest
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct DataExportRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<serde_json::Value>,
    pub created_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub export_format: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub export_url: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_size_bytes: Option<serde_json::Value>,
    pub id: ExportRequestId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<serde_json::Value>,
    pub status: ExportStatus,
    pub user_id: UserId,
}

impl Default for DataExportRequest {
    fn default() -> Self {
        Self {
            completed_at: Default::default(),
            created_at: "".to_string(),
            error_message: Default::default(),
            expires_at: Default::default(),
            export_format: Default::default(),
            export_url: Default::default(),
            file_size_bytes: Default::default(),
            id: ../primitives/ExportRequestId.schema.json::default(),
            started_at: Default::default(),
            status: ExportStatus.schema.json::default(),
            user_id: ../primitives/UserId.schema.json::default(),
        }
    }
}

