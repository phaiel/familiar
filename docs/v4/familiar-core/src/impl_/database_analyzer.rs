//! Impl module for database_analyzer types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for DatabaseAnalyzer

// Methods: new, analyze, is_service_file, service_from_path, check_direct_sqlx_usage, extract_query_type, check_row_mapping_patterns, check_pool_access, check_entity_definitions, extract_entity_name, check_store_usage
impl DatabaseAnalyzer { pub fn new (root : PathBuf) -> Self { Self { root } } # [doc = " Run database-specific analysis on services"] pub fn analyze (& self , files : & [PathBuf]) -> Vec < Issue > { let issues = Mutex :: new (Vec :: new ()) ; let service_files : Vec < _ > = files . iter () . filter (| f | self . is_service_file (f)) . collect () ; self . check_direct_sqlx_usage (& service_files , & issues) ; self . check_row_mapping_patterns (& service_files , & issues) ; self . check_pool_access (& service_files , & issues) ; self . check_entity_definitions (& service_files , & issues) ; self . check_store_usage (& service_files , & issues) ; issues . into_inner () . unwrap () } # [doc = " Check if file is in a target service"] fn is_service_file (& self , path : & PathBuf) -> bool { let path_str = path . to_string_lossy () ; TARGET_SERVICES . iter () . any (| service | { path_str . contains (& format ! ("services/{}" , service)) }) } # [doc = " Extract service name from file path"] fn service_from_path (& self , path : & PathBuf) -> Option < String > { let path_str = path . to_string_lossy () ; for service in TARGET_SERVICES { if path_str . contains (& format ! ("services/{}" , service)) { return Some (service . to_string ()) ; } } None } # [doc = " Check for direct sqlx::query() usage in services"] # [doc = " Services should use TigerDataStore methods instead"] fn check_direct_sqlx_usage (& self , files : & [& PathBuf] , issues : & Mutex < Vec < Issue > >) { let sqlx_query_re = Regex :: new (r"sqlx::query[^_]") . unwrap () ; let sqlx_query_as_re = Regex :: new (r"sqlx::query_as") . unwrap () ; let sqlx_query_scalar_re = Regex :: new (r"sqlx::query_scalar") . unwrap () ; files . par_iter () . for_each (| path | { if let Ok (content) = fs :: read_to_string (path) { let service = self . service_from_path (path) . unwrap_or_default () ; for (line_num , line) in content . lines () . enumerate () { if sqlx_query_re . is_match (line) || sqlx_query_as_re . is_match (line) || sqlx_query_scalar_re . is_match (line) { let mut locked = issues . lock () . unwrap () ; locked . push (Issue { file : path . to_path_buf () , line : line_num + 1 , kind : IssueKind :: DirectSqlxUsage { service : service . clone () , query_type : self . extract_query_type (line) , } , severity : Severity :: Error , message : format ! ("Direct sqlx usage in service '{}' - use TigerDataStore methods instead" , service) , fix : Some (Fix { description : "Use TigerDataStore.method() instead of direct sqlx query" . to_string () , replacement : None , }) , }) ; } } } }) ; } # [doc = " Extract query type from line"] fn extract_query_type (& self , line : & str) -> String { if line . contains ("sqlx::query_as") { "query_as" . to_string () } else if line . contains ("sqlx::query_scalar") { "query_scalar" . to_string () } else { "query" . to_string () } } # [doc = " Check for legacy row mapping patterns (DbEntityRow, etc.)"] fn check_row_mapping_patterns (& self , files : & [& PathBuf] , issues : & Mutex < Vec < Issue > >) { files . par_iter () . for_each (| path | { if let Ok (content) = fs :: read_to_string (path) { let service = self . service_from_path (path) . unwrap_or_default () ; for (line_num , line) in content . lines () . enumerate () { for row_type in LEGACY_ROW_TYPES { if line . contains (row_type) { let mut locked = issues . lock () . unwrap () ; locked . push (Issue { file : path . to_path_buf () , line : line_num + 1 , kind : IssueKind :: LegacyRowMapping { service : service . clone () , row_type : row_type . to_string () , } , severity : Severity :: Warning , message : format ! ("Legacy row mapper '{}' used in service '{}' - use SeaORM entities instead" , row_type , service) , fix : Some (Fix { description : format ! ("Replace '{}' with SeaORM entity from familiar_core::entities::db" , row_type) , replacement : None , }) , }) ; } } } } }) ; } # [doc = " Check for direct pool access (store.pool(), .pool())"] fn check_pool_access (& self , files : & [& PathBuf] , issues : & Mutex < Vec < Issue > >) { let pool_access_re = Regex :: new (r"\.pool\(\)") . unwrap () ; let pool_type_re = Regex :: new (r"Pool<Postgres>|PgPool") . unwrap () ; files . par_iter () . for_each (| path | { if let Ok (content) = fs :: read_to_string (path) { let service = self . service_from_path (path) . unwrap_or_default () ; for (line_num , line) in content . lines () . enumerate () { if pool_access_re . is_match (line) || pool_type_re . is_match (line) { let mut locked = issues . lock () . unwrap () ; locked . push (Issue { file : path . to_path_buf () , line : line_num + 1 , kind : IssueKind :: DirectPoolAccess { service : service . clone () , } , severity : Severity :: Error , message : format ! ("Direct pool access in service '{}' - use TigerDataStore methods instead" , service) , fix : Some (Fix { description : "Remove .pool() access and use TigerDataStore methods" . to_string () , replacement : None , }) , }) ; } } } }) ; } # [doc = " Check for entity definitions in services (should be in familiar-core)"] fn check_entity_definitions (& self , files : & [& PathBuf] , issues : & Mutex < Vec < Issue > >) { let derive_entity_re = Regex :: new (r"DeriveEntityModel|sea_orm\(table_name") . unwrap () ; let struct_entity_re = Regex :: new (r"pub struct \w+Entity") . unwrap () ; files . par_iter () . for_each (| path | { if let Ok (content) = fs :: read_to_string (path) { let service = self . service_from_path (path) . unwrap_or_default () ; for (line_num , line) in content . lines () . enumerate () { if derive_entity_re . is_match (line) || struct_entity_re . is_match (line) { let entity_name = self . extract_entity_name (& content , line_num) ; let mut locked = issues . lock () . unwrap () ; locked . push (Issue { file : path . to_path_buf () , line : line_num + 1 , kind : IssueKind :: EntityInService { service : service . clone () , entity_name : entity_name . clone () , } , severity : Severity :: Error , message : format ! ("SeaORM entity '{}' defined in service '{}' - move to familiar-core/src/entities/db/" , entity_name , service) , fix : Some (Fix { description : "Move entity to familiar_core::entities::db and import from there" . to_string () , replacement : None , }) , }) ; } } } }) ; } # [doc = " Extract entity name from context"] fn extract_entity_name (& self , content : & str , line_num : usize) -> String { let struct_re = Regex :: new (r"pub struct (\w+)") . unwrap () ; let lines : Vec < & str > = content . lines () . collect () ; for i in line_num . saturating_sub (5) ..= (line_num + 5) . min (lines . len () . saturating_sub (1)) { if let Some (caps) = struct_re . captures (lines . get (i) . unwrap_or (& "")) { return caps . get (1) . map (| m | m . as_str () . to_string ()) . unwrap_or_default () ; } } "Unknown" . to_string () } # [doc = " Check that services properly use TigerDataStore"] fn check_store_usage (& self , files : & [& PathBuf] , issues : & Mutex < Vec < Issue > >) { let sqlx_use_re = Regex :: new (r"use sqlx") . unwrap () ; let store_use_re = Regex :: new (r"TigerDataStore|familiar_core::infrastructure") . unwrap () ; files . par_iter () . for_each (| path | { if let Ok (content) = fs :: read_to_string (path) { let service = self . service_from_path (path) . unwrap_or_default () ; let has_sqlx_import = sqlx_use_re . is_match (& content) ; let has_store_import = store_use_re . is_match (& content) ; if has_sqlx_import && ! has_store_import { for (line_num , line) in content . lines () . enumerate () { if sqlx_use_re . is_match (line) { let mut locked = issues . lock () . unwrap () ; locked . push (Issue { file : path . to_path_buf () , line : line_num + 1 , kind : IssueKind :: BypassingStore { service : service . clone () , pattern : "sqlx import without TigerDataStore" . to_string () , } , severity : Severity :: Warning , message : format ! ("Service '{}' imports sqlx directly but not TigerDataStore - consider using familiar-core's database layer" , service) , fix : Some (Fix { description : "Import TigerDataStore from familiar_core::infrastructure" . to_string () , replacement : None , }) , }) ; break ; } } } } }) ; } }

