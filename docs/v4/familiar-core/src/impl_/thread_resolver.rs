//! Impl module for thread_resolver types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for ThreadResolver

// Methods: new, with_config, resolve, find_exact_match, find_fuzzy_match, get_cached, cache_resolution, clear_cache
impl ThreadResolver { # [doc = " Create a new thread resolver with database connection"] pub fn new (db : Arc < DatabaseConnection >) -> Self { Self { db , config : ResolverConfig :: default () , cache : std :: sync :: RwLock :: new (std :: collections :: HashMap :: new ()) , } } # [doc = " Create a new thread resolver with custom configuration"] pub fn with_config (db : Arc < DatabaseConnection > , config : ResolverConfig) -> Self { Self { db , config , cache : std :: sync :: RwLock :: new (std :: collections :: HashMap :: new ()) , } } # [doc = " Resolve a subject string to a thread ID"] # [doc = ""] # [doc = " Resolution order:"] # [doc = " 1. Check cache"] # [doc = " 2. Exact match on thread name"] # [doc = " 3. Fuzzy match (if enabled)"] # [doc = " 4. Semantic match (if enabled and Qdrant available)"] # [doc = " 5. Create new UUID if no match"] pub async fn resolve (& self , tenant_id : UUID , subject : & str) -> ResolverResult < UUID > { let tenant_uuid = tenant_id . as_uuid () ; let normalized = normalize_subject (subject) ; if let Some (cached) = self . get_cached (tenant_uuid , & normalized) { return Ok (cached) ; } if let Some (id) = self . find_exact_match (tenant_uuid , & normalized) . await ? { self . cache_resolution (tenant_uuid , & normalized , id) ; return Ok (id) ; } if self . config . enable_fuzzy { if let Some (id) = self . find_fuzzy_match (tenant_uuid , & normalized) . await ? { self . cache_resolution (tenant_uuid , & normalized , id) ; return Ok (id) ; } } let new_id = UUID :: new () ; self . cache_resolution (tenant_uuid , & normalized , new_id) ; Ok (new_id) } # [doc = " Find exact match in database"] # [doc = " "] # [doc = " Joins entity_registry with comp_content to match on text_content"] async fn find_exact_match (& self , tenant_id : uuid :: Uuid , subject : & str) -> ResolverResult < Option < UUID > > { use crate :: entities :: db :: physics :: { entity_registry , content } ; use sea_orm :: JoinType ; use sea_orm :: QuerySelect ; let result = entity_registry :: Entity :: find () . join (JoinType :: InnerJoin , entity_registry :: Relation :: Content . def ()) . filter (entity_registry :: Column :: TenantId . eq (tenant_id)) . filter (entity_registry :: Column :: EntityType . eq ("Thread")) . filter (content :: Column :: TextContent . eq (subject)) . one (self . db . as_ref ()) . await ? ; Ok (result . map (| r | UUID :: from_uuid (r . id . as_uuid ()))) } # [doc = " Find fuzzy match using Levenshtein distance"] # [doc = " "] # [doc = " Loads all threads for a tenant and compares text content"] async fn find_fuzzy_match (& self , tenant_id : uuid :: Uuid , subject : & str) -> ResolverResult < Option < UUID > > { use crate :: entities :: db :: physics :: { entity_registry , content } ; use sea_orm :: JoinType ; use sea_orm :: QuerySelect ; let threads = entity_registry :: Entity :: find () . join (JoinType :: InnerJoin , entity_registry :: Relation :: Content . def ()) . filter (entity_registry :: Column :: TenantId . eq (tenant_id)) . filter (entity_registry :: Column :: EntityType . eq ("Thread")) . find_also_related (content :: Entity) . all (self . db . as_ref ()) . await ? ; let best_match = threads . iter () . filter_map (| (entity , maybe_content) | { if let Some (content) = maybe_content { let text = & content . text_content ; let distance = levenshtein_distance (subject , text) ; if distance <= self . config . fuzzy_max_distance { Some ((entity , distance)) } else { None } } else { None } }) . min_by_key (| (_ , dist) | * dist) ; Ok (best_match . map (| (entity , _) | UUID :: from_uuid (entity . id . as_uuid ()))) } # [doc = " Get cached resolution"] fn get_cached (& self , tenant_id : uuid :: Uuid , subject : & str) -> Option < UUID > { let cache = self . cache . read () . ok () ? ; cache . get (& (tenant_id , subject . to_string ())) . copied () } # [doc = " Cache a resolution"] fn cache_resolution (& self , tenant_id : uuid :: Uuid , subject : & str , id : UUID) { if let Ok (mut cache) = self . cache . write () { if cache . len () > 10000 { cache . clear () ; } cache . insert ((tenant_id , subject . to_string ()) , id) ; } } # [doc = " Clear the resolution cache"] pub fn clear_cache (& self) { if let Ok (mut cache) = self . cache . write () { cache . clear () ; } } }

