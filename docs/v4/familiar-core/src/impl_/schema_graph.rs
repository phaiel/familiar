//! Impl module for schema_graph types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for SchemaGraph

// Methods: new, from_directory, from_directory_with_depth, add_definition_nodes, add_definition_edges, add_node, add_node_with_metadata, add_definition_node, add_edge, add_typed_edge, has_edge, kind, transitive_deps, transitive_deps_filtered, transitive_deps_petgraph, blast_radius, reverse_transitive_deps, dependencies, dependents, all_schemas, node_count, edge_count, edges_of_kind, edge_type_counts, by_dependency_count, by_reference_count, orphan_schemas, truly_isolated_schemas, consumer_only_schemas, orphans_by_category, to_dot, to_dot_filtered, topological_order
impl SchemaGraph { # [doc = " Create a new empty schema graph."] pub fn new () -> Self { Self { graph : DiGraph :: new () , node_map : HashMap :: new () , } } # [doc = " Build a schema graph from a directory of JSON schema files."] # [doc = ""] # [doc = " This performs a \"Discovery Walk\" as described in the traversal article:"] # [doc = " 1. **Seed**: Start with all `.json` files in the directory"] # [doc = " 2. **Visit**: Parse each file for `$ref` keys and `x-familiar-*` extensions"] # [doc = " 3. **Edge**: Add typed edges based on the relationship type"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `schema_dir` - Path to the json-schema directory"] # [doc = ""] # [doc = " # Returns"] # [doc = " A `SchemaGraph` with all schemas as nodes and typed edges."] pub fn from_directory (schema_dir : & Path) -> Result < Self , std :: io :: Error > { Self :: from_directory_with_depth (schema_dir , 0) } # [doc = " Build a schema graph from a directory with configurable depth."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `schema_dir` - Path to the json-schema directory"] # [doc = " * `depth` - How deep to traverse into properties (0 = unlimited)"] # [doc = ""] # [doc = " # Returns"] # [doc = " A `SchemaGraph` with all schemas as nodes and typed edges."] pub fn from_directory_with_depth (schema_dir : & Path , depth : usize) -> Result < Self , std :: io :: Error > { let mut graph = Self :: new () ; let schema_files = discover_schema_files (schema_dir) ? ; let mut parsed_schemas : HashMap < PathBuf , serde_json :: Value > = HashMap :: new () ; for path in & schema_files { let relative = path . strip_prefix (schema_dir) . map (| p | p . to_string_lossy () . to_string ()) . unwrap_or_else (| _ | path . file_name () . unwrap () . to_string_lossy () . to_string ()) ; if let Ok (content) = fs :: read_to_string (path) { if let Ok (json) = serde_json :: from_str :: < serde_json :: Value > (& content) { let kind = json . get ("x-familiar-kind") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) ; let title = json . get ("title") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) ; graph . add_node_with_metadata (& relative , kind , title) ; Self :: add_definition_nodes (& mut graph , & json , & relative) ; parsed_schemas . insert (path . clone () , json) ; } } } for (path , json) in & parsed_schemas { let relative = path . strip_prefix (schema_dir) . map (| p | p . to_string_lossy () . to_string ()) . unwrap_or_else (| _ | path . file_name () . unwrap () . to_string_lossy () . to_string ()) ; let familiar_refs = extract_typed_refs (json) ; for (ref_path , edge_kind) in familiar_refs { let normalized = normalize_ref (& relative , & ref_path) ; if ! normalized . is_empty () && graph . node_map . contains_key (& normalized) { graph . add_typed_edge (& relative , & normalized , edge_kind) ; } } let composition_refs = extract_all_type_refs (json , & relative , depth , 0) ; for (target , edge_kind) in composition_refs { if graph . node_map . contains_key (& target) { if ! graph . has_edge (& relative , & target) { graph . add_typed_edge (& relative , & target , edge_kind) ; } } } Self :: add_definition_edges (& mut graph , json , & relative , depth) ; } Ok (graph) } # [doc = " Add nodes for all definitions/$defs in a schema"] fn add_definition_nodes (graph : & mut SchemaGraph , json : & serde_json :: Value , file_path : & str) { if let Some (serde_json :: Value :: Object (defs)) = json . get ("definitions") { for (def_name , def_schema) in defs { let title = def_schema . get ("title") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) ; let kind = def_schema . get ("x-familiar-kind") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) . or_else (| | Some ("definition" . to_string ())) ; graph . add_definition_node (file_path , def_name , kind , title) ; } } if let Some (serde_json :: Value :: Object (defs)) = json . get ("$defs") { for (def_name , def_schema) in defs { let title = def_schema . get ("title") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) ; let kind = def_schema . get ("x-familiar-kind") . and_then (| v | v . as_str ()) . map (| s | s . to_string ()) . or_else (| | Some ("definition" . to_string ())) ; graph . add_definition_node (file_path , def_name , kind , title) ; } } } # [doc = " Add edges from local definitions to their references"] fn add_definition_edges (graph : & mut SchemaGraph , json : & serde_json :: Value , file_path : & str , depth : usize) { if let Some (serde_json :: Value :: Object (defs)) = json . get ("definitions") { for (def_name , def_schema) in defs { let def_id = format ! ("{}#{}" , file_path , def_name) ; let refs = extract_all_type_refs (def_schema , file_path , depth , 0) ; for (target , edge_kind) in refs { if graph . node_map . contains_key (& target) && graph . node_map . contains_key (& def_id) { if ! graph . has_edge (& def_id , & target) { graph . add_typed_edge (& def_id , & target , edge_kind) ; } } } } } if let Some (serde_json :: Value :: Object (defs)) = json . get ("$defs") { for (def_name , def_schema) in defs { let def_id = format ! ("{}#{}" , file_path , def_name) ; let refs = extract_all_type_refs (def_schema , file_path , depth , 0) ; for (target , edge_kind) in refs { if graph . node_map . contains_key (& target) && graph . node_map . contains_key (& def_id) { if ! graph . has_edge (& def_id , & target) { graph . add_typed_edge (& def_id , & target , edge_kind) ; } } } } } } # [doc = " Add a node to the graph if it doesn't exist."] pub fn add_node (& mut self , id : & str) -> NodeIndex { self . add_node_with_metadata (id , None , None) } # [doc = " Add a node with metadata to the graph if it doesn't exist."] pub fn add_node_with_metadata (& mut self , id : & str , kind : Option < String > , title : Option < String >) -> NodeIndex { if let Some (& idx) = self . node_map . get (id) { idx } else { let (file_path , definition) = if let Some (hash_pos) = id . find ('#') { (id [.. hash_pos] . to_string () , Some (id [hash_pos + 1 ..] . to_string ())) } else { (id . to_string () , None) } ; let node = SchemaNode { id : id . to_string () , file_path , definition , kind , title , } ; let idx = self . graph . add_node (node) ; self . node_map . insert (id . to_string () , idx) ; idx } } # [doc = " Add a local definition node to the graph."] pub fn add_definition_node (& mut self , file_path : & str , def_name : & str , kind : Option < String > , title : Option < String >) -> NodeIndex { let id = format ! ("{}#{}" , file_path , def_name) ; if let Some (& idx) = self . node_map . get (& id) { idx } else { let node = SchemaNode { id : id . clone () , file_path : file_path . to_string () , definition : Some (def_name . to_string ()) , kind , title , } ; let idx = self . graph . add_node (node) ; self . node_map . insert (id , idx) ; idx } } # [doc = " Add an edge between two schemas (legacy method, uses TypeRef)."] pub fn add_edge (& mut self , from : & str , to : & str) { self . add_typed_edge (from , to , EdgeKind :: TypeRef) ; } # [doc = " Add a typed edge between two schemas."] pub fn add_typed_edge (& mut self , from : & str , to : & str , kind : EdgeKind) { let from_idx = self . add_node (from) ; let to_idx = self . add_node (to) ; self . graph . add_edge (from_idx , to_idx , kind) ; } # [doc = " Check if an edge exists between two schemas."] pub fn has_edge (& self , from : & str , to : & str) -> bool { if let (Some (& from_idx) , Some (& to_idx)) = (self . node_map . get (from) , self . node_map . get (to)) { self . graph . contains_edge (from_idx , to_idx) } else { false } } # [doc = " Get the kind of a schema node."] pub fn kind (& self , schema_id : & str) -> Option < & str > { self . node_map . get (schema_id) . and_then (| & idx | self . graph [idx] . kind . as_deref ()) } # [doc = " Get all transitive dependencies for a set of root schemas."] # [doc = ""] # [doc = " This uses an **iterative DFS** (stack-based) approach as recommended"] # [doc = " in the traversal article. This is safer than recursive DFS because:"] # [doc = " - It won't stack overflow on deeply nested schemas"] # [doc = " - It works reliably in `build.rs` where stack size may be limited"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `roots` - Schema identifiers to start from (e.g., [\"entities/Moment\"])"] # [doc = ""] # [doc = " # Returns"] # [doc = " A `HashSet` of all schema identifiers that are transitively required."] pub fn transitive_deps (& self , roots : & [& str]) -> HashSet < String > { let mut required : HashSet < String > = HashSet :: new () ; let mut stack : Vec < NodeIndex > = Vec :: new () ; for root in roots { if let Some (& idx) = self . node_map . get (* root) { stack . push (idx) ; } } while let Some (node_idx) = stack . pop () { let schema_id = & self . graph [node_idx] . id ; if ! required . insert (schema_id . clone ()) { continue ; } for neighbor in self . graph . neighbors_directed (node_idx , Direction :: Outgoing) { stack . push (neighbor) ; } } required } # [doc = " Get all transitive dependencies, optionally filtered by edge types."] pub fn transitive_deps_filtered (& self , roots : & [& str] , edge_kinds : & [EdgeKind]) -> HashSet < String > { let mut required : HashSet < String > = HashSet :: new () ; let mut stack : Vec < NodeIndex > = Vec :: new () ; let edge_filter : HashSet < _ > = edge_kinds . iter () . collect () ; for root in roots { if let Some (& idx) = self . node_map . get (* root) { stack . push (idx) ; } } while let Some (node_idx) = stack . pop () { let schema_id = & self . graph [node_idx] . id ; if ! required . insert (schema_id . clone ()) { continue ; } for edge in self . graph . edges_directed (node_idx , Direction :: Outgoing) { if edge_filter . is_empty () || edge_filter . contains (edge . weight ()) { stack . push (edge . target ()) ; } } } required } # [doc = " Get all transitive dependencies using petgraph's built-in Dfs."] # [doc = ""] # [doc = " This is an alternative to `transitive_deps` that uses petgraph's"] # [doc = " optimized DFS implementation."] pub fn transitive_deps_petgraph (& self , roots : & [& str]) -> HashSet < String > { let mut required : HashSet < String > = HashSet :: new () ; for root in roots { if let Some (& start_idx) = self . node_map . get (* root) { let mut dfs = Dfs :: new (& self . graph , start_idx) ; while let Some (node_idx) = dfs . next (& self . graph) { required . insert (self . graph [node_idx] . id . clone ()) ; } } } required } # [doc = " Find all nodes affected if this node fails (reverse reachability)."] # [doc = ""] # [doc = " This is the \"Blast Radius\" analysis - if a resource goes down,"] # [doc = " which systems are affected?"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `node_id` - The schema that might fail (e.g., a resource)"] # [doc = " * `edge_kinds` - Types of edges to follow in reverse (empty = all)"] # [doc = ""] # [doc = " # Returns"] # [doc = " All schemas that would be affected (reverse transitive closure)"] pub fn blast_radius (& self , node_id : & str , edge_kinds : & [EdgeKind]) -> HashSet < String > { self . reverse_transitive_deps (node_id , edge_kinds) } # [doc = " Get all schemas that transitively depend on this one (reverse DFS)."] pub fn reverse_transitive_deps (& self , node_id : & str , edge_kinds : & [EdgeKind]) -> HashSet < String > { let mut affected : HashSet < String > = HashSet :: new () ; let mut stack : Vec < NodeIndex > = Vec :: new () ; let edge_filter : HashSet < _ > = edge_kinds . iter () . collect () ; if let Some (& start_idx) = self . node_map . get (node_id) { stack . push (start_idx) ; } while let Some (node_idx) = stack . pop () { let schema_id = & self . graph [node_idx] . id ; if ! affected . insert (schema_id . clone ()) { continue ; } for edge in self . graph . edges_directed (node_idx , Direction :: Incoming) { if edge_filter . is_empty () || edge_filter . contains (edge . weight ()) { stack . push (edge . source ()) ; } } } affected } # [doc = " Get direct dependencies (schemas this one references)."] pub fn dependencies (& self , schema_id : & str) -> Vec < & str > { self . node_map . get (schema_id) . map (| & idx | { self . graph . neighbors_directed (idx , Direction :: Outgoing) . map (| n | self . graph [n] . id . as_str ()) . collect () }) . unwrap_or_default () } # [doc = " Get direct dependents (schemas that reference this one)."] pub fn dependents (& self , schema_id : & str) -> Vec < & str > { self . node_map . get (schema_id) . map (| & idx | { self . graph . neighbors_directed (idx , Direction :: Incoming) . map (| n | self . graph [n] . id . as_str ()) . collect () }) . unwrap_or_default () } # [doc = " Get all schema identifiers in the graph."] pub fn all_schemas (& self) -> Vec < & str > { self . graph . node_weights () . map (| s | s . id . as_str ()) . collect () } # [doc = " Get the number of nodes in the graph."] pub fn node_count (& self) -> usize { self . graph . node_count () } # [doc = " Get the number of edges in the graph."] pub fn edge_count (& self) -> usize { self . graph . edge_count () } # [doc = " Get edges filtered by type."] pub fn edges_of_kind (& self , kinds : & [EdgeKind]) -> Vec < (& str , & str , EdgeKind) > { let kind_set : HashSet < _ > = kinds . iter () . collect () ; self . graph . edge_references () . filter (| e | kind_set . is_empty () || kind_set . contains (e . weight ())) . map (| e | { let from = self . graph [e . source ()] . id . as_str () ; let to = self . graph [e . target ()] . id . as_str () ; (from , to , * e . weight ()) }) . collect () } # [doc = " Count edges by type."] pub fn edge_type_counts (& self) -> HashMap < EdgeKind , usize > { let mut counts : HashMap < EdgeKind , usize > = HashMap :: new () ; for edge in self . graph . edge_references () { * counts . entry (* edge . weight ()) . or_insert (0) += 1 ; } counts } # [doc = " Get schemas sorted by dependency count (most dependencies first)."] pub fn by_dependency_count (& self) -> Vec < (& str , usize) > { let mut result : Vec < _ > = self . graph . node_indices () . map (| idx | { let name = self . graph [idx] . id . as_str () ; let deps = self . graph . neighbors_directed (idx , Direction :: Outgoing) . count () ; (name , deps) }) . collect () ; result . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; result } # [doc = " Get schemas sorted by reference count (most referenced first)."] pub fn by_reference_count (& self) -> Vec < (& str , usize) > { let mut result : Vec < _ > = self . graph . node_indices () . map (| idx | { let name = self . graph [idx] . id . as_str () ; let refs = self . graph . neighbors_directed (idx , Direction :: Incoming) . count () ; (name , refs) }) . collect () ; result . sort_by (| a , b | b . 1 . cmp (& a . 1)) ; result } # [doc = " Get all orphan schemas (nodes with no incoming edges)."] # [doc = " "] # [doc = " Orphan schemas are schemas that are not referenced by any other schema."] # [doc = " This excludes local definitions (schemas with # in their ID)."] # [doc = " "] # [doc = " # Returns"] # [doc = " A vector of tuples: (schema_id, file_path, kind, is_expected_root)"] # [doc = " where is_expected_root indicates if the schema is in a category that's"] # [doc = " typically a root (ecs/, queues/, nodes/, systems/)."] # [doc = " has_outgoing indicates if the schema references other schemas (is a consumer)."] pub fn orphan_schemas (& self) -> Vec < OrphanInfo > { let expected_root_categories = ["ecs" , "queues" , "nodes" , "systems" , "resources"] ; self . graph . node_indices () . filter_map (| idx | { let node = & self . graph [idx] ; if node . id . contains ('#') { return None ; } let incoming_count = self . graph . neighbors_directed (idx , Direction :: Incoming) . count () ; if incoming_count > 0 { return None ; } let outgoing_count = self . graph . neighbors_directed (idx , Direction :: Outgoing) . count () ; let category = node . file_path . split ('/') . next () . unwrap_or ("unknown") . to_string () ; let is_expected_root = expected_root_categories . iter () . any (| c | category == * c) ; Some (OrphanInfo { schema_id : node . id . clone () , file_path : node . file_path . clone () , category , kind : node . kind . clone () , is_expected_root , has_outgoing : outgoing_count > 0 , }) }) . collect () } # [doc = " Get truly isolated schemas - no incoming AND no outgoing edges."] # [doc = " These are the real orphans that need investigation."] pub fn truly_isolated_schemas (& self) -> Vec < OrphanInfo > { self . orphan_schemas () . into_iter () . filter (| o | ! o . has_outgoing) . collect () } # [doc = " Get consumer-only schemas - have outgoing edges but no incoming."] # [doc = " These are \"leaf\" schemas that consume primitives/types but aren't consumed."] pub fn consumer_only_schemas (& self) -> Vec < OrphanInfo > { self . orphan_schemas () . into_iter () . filter (| o | o . has_outgoing) . collect () } # [doc = " Get orphan schemas grouped by category."] pub fn orphans_by_category (& self) -> HashMap < String , Vec < OrphanInfo > > { let orphans = self . orphan_schemas () ; let mut by_category : HashMap < String , Vec < OrphanInfo > > = HashMap :: new () ; for orphan in orphans { by_category . entry (orphan . category . clone ()) . or_default () . push (orphan) ; } by_category } # [doc = " Export the graph in DOT format for visualization with Graphviz."] pub fn to_dot (& self) -> String { let mut dot = String :: from ("digraph G {\n") ; dot . push_str ("  rankdir=LR;\n") ; dot . push_str ("  node [shape=box];\n") ; for idx in self . graph . node_indices () { let node = & self . graph [idx] ; let label = node . title . as_deref () . unwrap_or (& node . id) ; let color = match node . kind . as_deref () { Some ("node") => "#2196F3" , Some ("system") => "#4CAF50" , Some ("resource") => "#FF9800" , Some ("queue") => "#9C27B0" , Some ("entity") => "#00BCD4" , Some ("primitive") => "#607D8B" , _ => "#9E9E9E" , } ; dot . push_str (& format ! ("  \"{}\" [label=\"{}\", fillcolor=\"{}\", style=filled];\n" , node . id , label , color)) ; } for edge in self . graph . edge_references () { let from = & self . graph [edge . source ()] . id ; let to = & self . graph [edge . target ()] . id ; let color = edge . weight () . color () ; let label = edge . weight () . label () ; dot . push_str (& format ! ("  \"{}\" -> \"{}\" [color=\"{}\", label=\"{}\"];\n" , from , to , color , label)) ; } dot . push_str ("}\n") ; dot } # [doc = " Export the graph in DOT format filtered by edge types."] pub fn to_dot_filtered (& self , edge_kinds : & [EdgeKind]) -> String { let kind_set : HashSet < _ > = edge_kinds . iter () . collect () ; let mut dot = String :: from ("digraph G {\n") ; dot . push_str ("  rankdir=LR;\n") ; dot . push_str ("  node [shape=box];\n") ; let mut relevant_nodes : HashSet < NodeIndex > = HashSet :: new () ; for edge in self . graph . edge_references () { if kind_set . is_empty () || kind_set . contains (edge . weight ()) { relevant_nodes . insert (edge . source ()) ; relevant_nodes . insert (edge . target ()) ; } } for idx in relevant_nodes . iter () { let node = & self . graph [* idx] ; let label = node . title . as_deref () . unwrap_or (& node . id) ; dot . push_str (& format ! ("  \"{}\" [label=\"{}\"];\n" , node . id , label)) ; } for edge in self . graph . edge_references () { if kind_set . is_empty () || kind_set . contains (edge . weight ()) { let from = & self . graph [edge . source ()] . id ; let to = & self . graph [edge . target ()] . id ; let color = edge . weight () . color () ; dot . push_str (& format ! ("  \"{}\" -> \"{}\" [color=\"{}\"];\n" , from , to , color)) ; } } dot . push_str ("}\n") ; dot } # [doc = " Perform topological sort for codegen ordering."] # [doc = ""] # [doc = " Returns schemas in an order where dependencies come before dependents."] # [doc = " This is useful for generating a single file where types are defined"] # [doc = " in the correct order."] # [doc = ""] # [doc = " Returns `None` if there are cycles in the graph."] pub fn topological_order (& self) -> Option < Vec < & str > > { petgraph :: algo :: toposort (& self . graph , None) . ok () . map (| sorted | { sorted . into_iter () . map (| idx | self . graph [idx] . id . as_str ()) . collect () }) } }

// Trait impl: Default
impl Default for SchemaGraph { fn default () -> Self { Self :: new () } }

