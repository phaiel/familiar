//! Impl module for envelope_v1 types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for EnvelopeV1

// Methods: new, command, event, trace, with_course_id, with_shuttle_id, with_causation, with_producer, kafka_key, kafka_headers
impl EnvelopeV1 { # [doc = " Create a new envelope with the given payload"] pub fn new (tenant_id : TenantId , user_id : UserId , correlation_id : impl Into < String > , payload : Payload ,) -> Self { let message_type = format ! ("familiar.{}" , payload . type_name ()) ; Self { message_id : Ulid :: new () . to_string () , message_type , occurred_at : Utc :: now () , tenant_id , course_id : None , shuttle_id : None , user_id , correlation_id : correlation_id . into () , causation_id : None , producer : ProducerInfo :: api () , schema : SchemaInfo :: default () , payload , } } # [doc = " Create a command envelope"] pub fn command (tenant_id : TenantId , user_id : UserId , correlation_id : impl Into < String > , payload : Payload ,) -> Self { debug_assert ! (payload . is_command () , "payload must be a command") ; let mut envelope = Self :: new (tenant_id , user_id , correlation_id , payload) ; envelope . producer = ProducerInfo :: api () ; envelope } # [doc = " Create an event envelope (typically from worker)"] pub fn event (tenant_id : TenantId , user_id : UserId , correlation_id : impl Into < String > , payload : Payload ,) -> Self { debug_assert ! (payload . is_event () , "payload must be an event") ; let mut envelope = Self :: new (tenant_id , user_id , correlation_id , payload) ; envelope . producer = ProducerInfo :: worker () ; envelope } # [doc = " Create a trace envelope (typically from worker)"] pub fn trace (tenant_id : TenantId , user_id : UserId , correlation_id : impl Into < String > , payload : Payload ,) -> Self { debug_assert ! (payload . is_trace () , "payload must be a trace") ; let mut envelope = Self :: new (tenant_id , user_id , correlation_id , payload) ; envelope . producer = ProducerInfo :: worker () ; envelope } # [doc = " Set the course ID (persistent session/history bucket)"] pub fn with_course_id (mut self , course_id : CourseId) -> Self { self . course_id = Some (course_id) ; self . correlation_id = course_id . to_string () ; self } # [doc = " Set the shuttle ID (transient unit of work)"] pub fn with_shuttle_id (mut self , shuttle_id : ShuttleId) -> Self { self . shuttle_id = Some (shuttle_id) ; self } # [doc = " Set the causation ID (upstream message that caused this)"] pub fn with_causation (mut self , causation_id : impl Into < String >) -> Self { self . causation_id = Some (causation_id . into ()) ; self } # [doc = " Set custom producer info"] pub fn with_producer (mut self , producer : ProducerInfo) -> Self { self . producer = producer ; self } # [doc = " Get the Kafka key for this envelope"] pub fn kafka_key (& self) -> String { let session_key = self . course_id . map (| c | c . to_string ()) . unwrap_or_else (| | self . correlation_id . clone ()) ; format ! ("{}:{}" , self . tenant_id , session_key) } # [doc = " Get Kafka headers for this envelope"] pub fn kafka_headers (& self) -> Vec < (& 'static str , String) > { let mut headers = vec ! [("message_type" , self . message_type . clone ()) , ("tenant_id" , self . tenant_id . to_string ()) , ("content_type" , "application/json" . to_string ()) ,] ; if let Some (course_id) = & self . course_id { headers . push (("course_id" , course_id . to_string ())) ; } if let Some (shuttle_id) = & self . shuttle_id { headers . push (("shuttle_id" , shuttle_id . to_string ())) ; } headers } }

