//! Impl module for tiger_data_store types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for TigerDataStore

// Methods: create_tenant, get_tenant, create_member, get_tenant_members, create_channel, get_channels, get_channel, create_message, get_messages, get_conversation_history, create_familiar_entity, get_familiar_entities, update_entity_status, set_entity_qdrant_id
impl TigerDataStore { pub async fn create_tenant (& self , input : CreateTenantInput) -> Result < Tenant , DbStoreError > { let now = Utc :: now () ; let id = TenantId :: new () ; let model = tenant :: ActiveModel { id : Set (id) , name : Set (input . name . clone ()) , settings : Set (input . settings . clone () . unwrap_or_default ()) , created_at : Set (now) , updated_at : Set (now) , } ; tenant :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (Tenant { meta : SystemEntityMeta { id : id . as_uuid () . into () , timestamps : Timestamps { created_at : now , updated_at : now } , } , name : input . name , settings : input . settings . unwrap_or_default () , }) } pub async fn get_tenant (& self , tenant_id : TenantId) -> Result < Option < Tenant > , DbStoreError > { let result = tenant :: Entity :: find_by_id (tenant_id) . one (& self . db) . await ? ; Ok (result . map (| m | Tenant { meta : SystemEntityMeta { id : m . id . as_uuid () . into () , timestamps : Timestamps { created_at : m . created_at , updated_at : m . updated_at } , } , name : m . name , settings : m . settings , })) } pub async fn create_member (& self , input : CreateMemberInput) -> Result < TenantMember , DbStoreError > { let now = Utc :: now () ; let id = UserId :: new () ; let model = tenant_member :: ActiveModel { id : Set (id) , tenant_id : Set (input . tenant_id) , name : Set (input . name . clone ()) , email : Set (input . email . clone ()) , avatar_url : Set (input . avatar_url . clone ()) , role : Set (match input . role . unwrap_or (MemberRole :: Member) { MemberRole :: Admin => tenant_member :: MemberRole :: Admin , MemberRole :: Member => tenant_member :: MemberRole :: Member , MemberRole :: Guest => tenant_member :: MemberRole :: Guest , }) , settings : Set (serde_json :: json ! ({ })) , created_at : Set (now) , updated_at : Set (now) , } ; tenant_member :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (TenantMember { meta : EntityMeta { id : id . as_uuid () . into () , tenant_id : input . tenant_id , timestamps : Timestamps { created_at : now , updated_at : now } , } , name : input . name , email : input . email , avatar_url : input . avatar_url , role : input . role . unwrap_or (MemberRole :: Member) , settings : serde_json :: json ! ({ }) , }) } pub async fn get_tenant_members (& self , tenant_id : TenantId) -> Result < Vec < TenantMember > , DbStoreError > { let results = tenant_member :: Entity :: find () . filter (tenant_member :: Column :: TenantId . eq (tenant_id)) . order_by_asc (tenant_member :: Column :: Name) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | TenantMember { meta : EntityMeta { id : m . id . as_uuid () . into () , tenant_id : m . tenant_id , timestamps : Timestamps { created_at : m . created_at , updated_at : m . updated_at } , } , name : m . name , email : m . email , avatar_url : m . avatar_url , role : match m . role { tenant_member :: MemberRole :: Admin => MemberRole :: Admin , tenant_member :: MemberRole :: Member => MemberRole :: Member , tenant_member :: MemberRole :: Guest => MemberRole :: Guest , } , settings : m . settings , }) . collect ()) } pub async fn create_channel (& self , input : CreateChannelInput) -> Result < Channel , DbStoreError > { let now = Utc :: now () ; let id = ChannelId :: new () ; let model = channel :: ActiveModel { id : Set (id) , tenant_id : Set (input . tenant_id) , owner_id : Set (input . owner_id) , name : Set (input . name . clone ()) , description : Set (input . description . clone ()) , channel_type : Set (match input . channel_type . unwrap_or_default () { ChannelType :: Personal => channel :: ChannelType :: Personal , ChannelType :: Family => channel :: ChannelType :: Family , ChannelType :: Shared => channel :: ChannelType :: Shared , }) , settings : Set (serde_json :: json ! ({ })) , created_at : Set (now) , updated_at : Set (now) , version : Set (0) , } ; channel :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (Channel { meta : EntityMeta { id : id . into () , tenant_id : input . tenant_id , timestamps : Timestamps { created_at : now , updated_at : now } , } , owner_id : input . owner_id , name : input . name , description : input . description , channel_type : input . channel_type . unwrap_or_default () , settings : serde_json :: json ! ({ }) , }) } pub async fn get_channels (& self , tenant_id : Uuid , options : ListChannelsOptions) -> Result < Vec < Channel > , DbStoreError > { let mut query = channel :: Entity :: find () . filter (channel :: Column :: TenantId . eq (tenant_id)) ; if let Some (ct) = options . channel_type { query = query . filter (channel :: Column :: ChannelType . eq (match ct { ChannelType :: Personal => channel :: ChannelType :: Personal , ChannelType :: Family => channel :: ChannelType :: Family , ChannelType :: Shared => channel :: ChannelType :: Shared , })) ; } if let Some (owner) = options . owner_id { query = query . filter (channel :: Column :: OwnerId . eq (owner . as_uuid ())) ; } let results = query . order_by_desc (channel :: Column :: CreatedAt) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | Channel { meta : EntityMeta { id : m . id . into () , tenant_id : m . tenant_id . into () , timestamps : Timestamps { created_at : m . created_at , updated_at : m . updated_at } , } , owner_id : m . owner_id . map (| o | o . into ()) , name : m . name , description : m . description , channel_type : match m . channel_type { channel :: ChannelType :: Personal => ChannelType :: Personal , channel :: ChannelType :: Family => ChannelType :: Family , channel :: ChannelType :: Shared => ChannelType :: Shared , } , settings : m . settings , }) . collect ()) } pub async fn get_channel (& self , channel_id : Uuid) -> Result < Option < Channel > , DbStoreError > { let result = channel :: Entity :: find_by_id (channel_id) . one (& self . db) . await ? ; Ok (result . map (| m | Channel { meta : EntityMeta { id : m . id . into () , tenant_id : m . tenant_id . into () , timestamps : Timestamps { created_at : m . created_at , updated_at : m . updated_at } , } , owner_id : m . owner_id . map (| o | o . into ()) , name : m . name , description : m . description , channel_type : match m . channel_type { channel :: ChannelType :: Personal => ChannelType :: Personal , channel :: ChannelType :: Family => ChannelType :: Family , channel :: ChannelType :: Shared => ChannelType :: Shared , } , settings : m . settings , })) } pub async fn create_message (& self , input : CreateMessageInput) -> Result < Message , DbStoreError > { let now = Utc :: now () ; let id = MessageId :: new () ; let model = message :: ActiveModel { id : Set (id) , channel_id : Set (input . channel_id) , sender_id : Set (input . sender_id) , parent_id : Set (input . parent_id) , role : Set (match input . role { MessageRole :: User => message :: MessageRole :: User , MessageRole :: Assistant => message :: MessageRole :: Assistant , MessageRole :: System => message :: MessageRole :: System , }) , content : Set (input . content . clone ()) , agent_speaker : Set (input . agent_speaker . clone ()) , thinking_steps : Set (input . thinking_steps . clone () . unwrap_or_default ()) , tool_calls : Set (input . tool_calls . clone () . unwrap_or_default ()) , weave_result : Set (input . weave_result . clone ()) , metadata : Set (input . metadata . clone () . unwrap_or_default ()) , created_at : Set (now) , } ; message :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (Message { id : id . as_uuid () . into () , channel_id : input . channel_id , sender_id : input . sender_id , parent_id : input . parent_id , role : input . role , content : input . content , agent_speaker : input . agent_speaker , thinking_steps : input . thinking_steps . unwrap_or_default () , tool_calls : input . tool_calls . unwrap_or_default () , weave_result : input . weave_result , metadata : input . metadata . unwrap_or_default () , created_at : now , }) } pub async fn get_messages (& self , channel_id : ChannelId , options : ListMessagesOptions) -> Result < Vec < Message > , DbStoreError > { let results : Vec < message :: Model > = message :: Entity :: find () . filter (message :: Column :: ChannelId . eq (channel_id)) . order_by_desc (message :: Column :: CreatedAt) . limit (options . limit . unwrap_or (50) as u64) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | Message { id : m . id . as_uuid () . into () , channel_id : m . channel_id , sender_id : m . sender_id , parent_id : m . parent_id , role : match m . role { message :: MessageRole :: User => MessageRole :: User , message :: MessageRole :: Assistant => MessageRole :: Assistant , message :: MessageRole :: System => MessageRole :: System , } , content : m . content , agent_speaker : m . agent_speaker , thinking_steps : m . thinking_steps , tool_calls : m . tool_calls , weave_result : m . weave_result , metadata : m . metadata , created_at : m . created_at , }) . collect ()) } pub async fn get_conversation_history (& self , channel_id : ChannelId , limit : i64) -> Result < Vec < ConversationMessage > , DbStoreError > { let results : Vec < message :: Model > = message :: Entity :: find () . filter (message :: Column :: ChannelId . eq (channel_id)) . order_by_desc (message :: Column :: CreatedAt) . limit (limit as u64) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | ConversationMessage { role : match m . role { message :: MessageRole :: User => "user" . to_string () , message :: MessageRole :: Assistant => "assistant" . to_string () , message :: MessageRole :: System => "system" . to_string () , } , content : m . content , }) . collect ()) } pub async fn create_familiar_entity (& self , input : CreateEntityInput) -> Result < FamiliarEntity , DbStoreError > { let now = Utc :: now () ; let id = EntityId :: new () ; let model = familiar_entity :: ActiveModel { id : Set (id) , tenant_id : Set (input . tenant_id) , entity_type : Set (match input . entity_type { FamiliarEntityType :: Moment => familiar_entity :: FamiliarEntityType :: Moment , FamiliarEntityType :: Pulse => familiar_entity :: FamiliarEntityType :: Pulse , FamiliarEntityType :: Intent => familiar_entity :: FamiliarEntityType :: Intent , FamiliarEntityType :: Thread => familiar_entity :: FamiliarEntityType :: Thread , FamiliarEntityType :: Bond => familiar_entity :: FamiliarEntityType :: Bond , FamiliarEntityType :: Motif => familiar_entity :: FamiliarEntityType :: Motif , FamiliarEntityType :: Filament => familiar_entity :: FamiliarEntityType :: Filament , FamiliarEntityType :: Focus => familiar_entity :: FamiliarEntityType :: Focus , }) , content : Set (input . content . clone ()) , subject : Set (input . subject . clone ()) , physics : Set (input . physics . as_ref () . map (| p | serde_json :: to_value (p) . unwrap_or_default ())) , qdrant_point_id : Set (None) , qdrant_collection : Set (Some ("familiar_entities" . to_string ())) , source_message_id : Set (input . source_message_id) , source_channel_id : Set (input . source_channel_id) , status : Set (familiar_entity :: EntityStatus :: Pending) , reviewed_by : Set (None) , reviewed_at : Set (None) , metadata : Set (input . metadata . clone () . unwrap_or_default ()) , created_at : Set (now) , updated_at : Set (now) , } ; familiar_entity :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (FamiliarEntity { id : id . into () , tenant_id : input . tenant_id , entity_type : input . entity_type , content : input . content , subject : input . subject , physics : input . physics , qdrant_point_id : None , qdrant_collection : Some ("familiar_entities" . to_string ()) , source_message_id : input . source_message_id , source_channel_id : input . source_channel_id , status : EntityStatus :: Pending , reviewed_by : None , reviewed_at : None , metadata : input . metadata . unwrap_or_default () , created_at : now , updated_at : now , }) } pub async fn get_familiar_entities (& self , tenant_id : Uuid , options : ListEntitiesOptions) -> Result < Vec < FamiliarEntity > , DbStoreError > { let mut query = familiar_entity :: Entity :: find () . filter (familiar_entity :: Column :: TenantId . eq (tenant_id)) ; if let Some (status) = options . status { query = query . filter (familiar_entity :: Column :: Status . eq (match status { EntityStatus :: Pending => familiar_entity :: EntityStatus :: Pending , EntityStatus :: Approved => familiar_entity :: EntityStatus :: Approved , EntityStatus :: Rejected => familiar_entity :: EntityStatus :: Rejected , EntityStatus :: AutoSpawned => familiar_entity :: EntityStatus :: AutoSpawned , })) ; } let results = query . order_by_desc (familiar_entity :: Column :: CreatedAt) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | FamiliarEntity { id : m . id . into () , tenant_id : m . tenant_id . into () , entity_type : match m . entity_type { familiar_entity :: FamiliarEntityType :: Moment => FamiliarEntityType :: Moment , familiar_entity :: FamiliarEntityType :: Pulse => FamiliarEntityType :: Pulse , familiar_entity :: FamiliarEntityType :: Intent => FamiliarEntityType :: Intent , familiar_entity :: FamiliarEntityType :: Thread => FamiliarEntityType :: Thread , familiar_entity :: FamiliarEntityType :: Bond => FamiliarEntityType :: Bond , familiar_entity :: FamiliarEntityType :: Motif => FamiliarEntityType :: Motif , familiar_entity :: FamiliarEntityType :: Filament => FamiliarEntityType :: Filament , familiar_entity :: FamiliarEntityType :: Focus => FamiliarEntityType :: Focus , } , content : m . content , subject : m . subject , physics : m . physics . map (| p | serde_json :: from_value (p) . unwrap_or_default ()) , qdrant_point_id : m . qdrant_point_id . map (| q | q . into ()) , qdrant_collection : m . qdrant_collection , source_message_id : m . source_message_id . map (| s | s . into ()) , source_channel_id : m . source_channel_id . map (| s | s . into ()) , status : match m . status { familiar_entity :: EntityStatus :: Pending => EntityStatus :: Pending , familiar_entity :: EntityStatus :: Approved => EntityStatus :: Approved , familiar_entity :: EntityStatus :: Rejected => EntityStatus :: Rejected , familiar_entity :: EntityStatus :: AutoSpawned => EntityStatus :: AutoSpawned , } , reviewed_by : m . reviewed_by . map (| r | r . into ()) , reviewed_at : m . reviewed_at . map (| r | r . into ()) , metadata : m . metadata , created_at : m . created_at , updated_at : m . updated_at , }) . collect ()) } pub async fn update_entity_status (& self , entity_id : Uuid , input : UpdateEntityStatusInput) -> Result < () , DbStoreError > { let now = Utc :: now () ; familiar_entity :: Entity :: update_many () . col_expr (familiar_entity :: Column :: Status , Expr :: value (match input . status { EntityStatus :: Pending => "pending" , EntityStatus :: Approved => "approved" , EntityStatus :: Rejected => "rejected" , EntityStatus :: AutoSpawned => "auto_spawned" , })) . col_expr (familiar_entity :: Column :: ReviewedBy , Expr :: value (input . reviewed_by . map (| r | r . as_uuid ()))) . col_expr (familiar_entity :: Column :: ReviewedAt , Expr :: value (Some (now))) . col_expr (familiar_entity :: Column :: UpdatedAt , Expr :: value (now)) . filter (familiar_entity :: Column :: Id . eq (entity_id)) . exec (& self . db) . await ? ; Ok (()) } pub async fn set_entity_qdrant_id (& self , entity_id : Uuid , qdrant_point_id : Uuid , collection : & str) -> Result < () , DbStoreError > { let now = Utc :: now () ; familiar_entity :: Entity :: update_many () . col_expr (familiar_entity :: Column :: QdrantPointId , Expr :: value (Some (qdrant_point_id))) . col_expr (familiar_entity :: Column :: QdrantCollection , Expr :: value (Some (collection))) . col_expr (familiar_entity :: Column :: UpdatedAt , Expr :: value (now)) . filter (familiar_entity :: Column :: Id . eq (entity_id)) . exec (& self . db) . await ? ; Ok (()) } }

// Methods: create_user, get_user, get_user_by_email, get_user_password_hash, update_user, verify_user_email, update_user_password, create_session, validate_session, delete_session, delete_user_sessions, create_magic_link, get_magic_link_by_token, consume_magic_link, record_consent, get_consent_records, create_audit_log, create_email_invitation, create_code_invitation, get_invitation_by_code, get_invitation_by_email, use_invitation, is_invitation_valid, create_join_request, get_pending_join_requests, review_join_request, add_user_to_tenant, get_user_memberships, is_user_member, is_user_admin
impl TigerDataStore { pub async fn create_user (& self , input : CreateUserInput) -> Result < User , DbStoreError > { let now = Utc :: now () ; let id = UserId :: new () ; let model = user :: ActiveModel { id : Set (id) , email : Set (input . email . clone ()) , email_verified : Set (false) , password_hash : Set (input . password_hash . clone ()) , name : Set (input . name . clone ()) , avatar_url : Set (input . avatar_url . clone ()) , primary_tenant_id : Set (input . primary_tenant_id) , settings : Set (serde_json :: json ! ({ })) , gdpr_consents : Set (serde_json :: json ! ({ })) , deletion_requested_at : Set (None) , created_at : Set (now) , updated_at : Set (now) , } ; user :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (User { meta : SystemEntityMeta { id : id . as_uuid () . into () , timestamps : Timestamps { created_at : now , updated_at : now } , } , email : input . email , email_verified : false , name : input . name , avatar_url : input . avatar_url , primary_tenant_id : input . primary_tenant_id , settings : serde_json :: json ! ({ }) , gdpr_consents : serde_json :: json ! ({ }) , deletion_requested_at : None , }) } pub async fn get_user (& self , user_id : UserId) -> Result < Option < User > , DbStoreError > { let result = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? ; Ok (result . map (| m | User { meta : SystemEntityMeta { id : m . id . as_uuid () . into () , timestamps : Timestamps { created_at : m . created_at , updated_at : m . updated_at } , } , email : m . email , email_verified : m . email_verified , name : m . name , avatar_url : m . avatar_url , primary_tenant_id : m . primary_tenant_id , settings : m . settings , gdpr_consents : m . gdpr_consents , deletion_requested_at : m . deletion_requested_at , })) } pub async fn get_user_by_email (& self , email : & str) -> Result < Option < User > , DbStoreError > { let result = user :: Entity :: find () . filter (user :: Column :: Email . eq (email)) . one (& self . db) . await ? ; Ok (result . map (| m | User { meta : SystemEntityMeta { id : m . id . into () , timestamps : Timestamps { created_at : m . created_at , updated_at : m . updated_at } , } , email : m . email , email_verified : m . email_verified , name : m . name , avatar_url : m . avatar_url , primary_tenant_id : m . primary_tenant_id . map (| t | t . into ()) , settings : m . settings , gdpr_consents : m . gdpr_consents , deletion_requested_at : m . deletion_requested_at , })) } pub async fn get_user_password_hash (& self , user_id : Uuid) -> Result < Option < String > , DbStoreError > { let result = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? ; Ok (result . and_then (| m | m . password_hash)) } pub async fn update_user (& self , user_id : Uuid , input : UpdateUserInput) -> Result < () , DbStoreError > { let now = Utc :: now () ; let mut model : user :: ActiveModel = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? . ok_or_else (| | DbStoreError :: not_found ("User" , user_id . to_string ())) ? . into () ; if let Some (name) = input . name { model . name = Set (name) ; } if let Some (avatar) = input . avatar_url { model . avatar_url = Set (Some (avatar)) ; } if let Some (tenant) = input . primary_tenant_id { model . primary_tenant_id = Set (Some (tenant)) ; } if let Some (settings) = input . settings { model . settings = Set (settings) ; } model . updated_at = Set (now) ; model . update (& self . db) . await ? ; Ok (()) } pub async fn verify_user_email (& self , user_id : Uuid) -> Result < () , DbStoreError > { let now = Utc :: now () ; user :: Entity :: update_many () . col_expr (user :: Column :: EmailVerified , Expr :: value (true)) . col_expr (user :: Column :: UpdatedAt , Expr :: value (now)) . filter (user :: Column :: Id . eq (user_id)) . exec (& self . db) . await ? ; Ok (()) } pub async fn update_user_password (& self , user_id : Uuid , password_hash : & str) -> Result < () , DbStoreError > { let now = Utc :: now () ; user :: Entity :: update_many () . col_expr (user :: Column :: PasswordHash , Expr :: value (Some (password_hash))) . col_expr (user :: Column :: UpdatedAt , Expr :: value (now)) . filter (user :: Column :: Id . eq (user_id)) . exec (& self . db) . await ? ; Ok (()) } pub async fn create_session (& self , input : CreateSessionInput) -> Result < AuthSession , DbStoreError > { let now = Utc :: now () ; let id = SessionId :: new () ; let expires_at = now + Duration :: hours (input . expires_in_hours) ; let model = session :: ActiveModel { id : Set (id) , user_id : Set (input . user_id) , token_hash : Set (input . token_hash . clone ()) , user_agent : Set (input . user_agent . clone ()) , ip_address : Set (input . ip_address . clone ()) , expires_at : Set (expires_at) , created_at : Set (now) , version : Set (0) , } ; session :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (AuthSession { id : id . as_uuid () . into () , user_id : input . user_id , token_hash : input . token_hash , user_agent : input . user_agent , ip_address : input . ip_address , expires_at , created_at : now , }) } pub async fn validate_session (& self , token_hash : & str) -> Result < Option < UserId > , DbStoreError > { let now = Utc :: now () ; let result = session :: Entity :: find () . filter (session :: Column :: TokenHash . eq (token_hash)) . filter (session :: Column :: ExpiresAt . gt (now)) . one (& self . db) . await ? ; Ok (result . map (| m | m . user_id)) } pub async fn delete_session (& self , session_id : SessionId) -> Result < () , DbStoreError > { session :: Entity :: delete_by_id (session_id) . exec (& self . db) . await ? ; Ok (()) } pub async fn delete_user_sessions (& self , user_id : UserId) -> Result < () , DbStoreError > { session :: Entity :: delete_many () . filter (session :: Column :: UserId . eq (user_id)) . exec (& self . db) . await ? ; Ok (()) } pub async fn create_magic_link (& self , input : CreateMagicLinkInput , token_hash : String) -> Result < MagicLink , DbStoreError > { let now = Utc :: now () ; let id = MagicLinkId :: new () ; let expires_at = now + Duration :: minutes (input . expires_in_minutes) ; let model = magic_link :: ActiveModel { id : Set (id) , email : Set (input . email . clone ()) , token_hash : Set (token_hash . clone ()) , purpose : Set (match input . purpose { MagicLinkPurpose :: Login => magic_link :: MagicLinkPurpose :: Login , MagicLinkPurpose :: Signup => magic_link :: MagicLinkPurpose :: Signup , MagicLinkPurpose :: VerifyEmail => magic_link :: MagicLinkPurpose :: VerifyEmail , MagicLinkPurpose :: PasswordReset => magic_link :: MagicLinkPurpose :: PasswordReset , }) , metadata : Set (input . metadata . clone () . unwrap_or_default ()) , expires_at : Set (expires_at) , used_at : Set (None) , created_at : Set (now) , } ; magic_link :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (MagicLink { id : id . into () , email : input . email , purpose : input . purpose , metadata : input . metadata . unwrap_or_default () , expires_at , used_at : None , created_at : now , }) } pub async fn get_magic_link_by_token (& self , token_hash : & str) -> Result < Option < MagicLink > , DbStoreError > { let result = magic_link :: Entity :: find () . filter (magic_link :: Column :: TokenHash . eq (token_hash)) . one (& self . db) . await ? ; Ok (result . map (| m | MagicLink { id : m . id . into () , email : m . email , purpose : match m . purpose { magic_link :: MagicLinkPurpose :: Login => MagicLinkPurpose :: Login , magic_link :: MagicLinkPurpose :: Signup => MagicLinkPurpose :: Signup , magic_link :: MagicLinkPurpose :: VerifyEmail => MagicLinkPurpose :: VerifyEmail , magic_link :: MagicLinkPurpose :: PasswordReset => MagicLinkPurpose :: PasswordReset , } , metadata : m . metadata , expires_at : m . expires_at , used_at : m . used_at , created_at : m . created_at , })) } pub async fn consume_magic_link (& self , link_id : Uuid) -> Result < () , DbStoreError > { let now = Utc :: now () ; magic_link :: Entity :: update_many () . col_expr (magic_link :: Column :: UsedAt , Expr :: value (Some (now))) . filter (magic_link :: Column :: Id . eq (link_id)) . exec (& self . db) . await ? ; Ok (()) } pub async fn record_consent (& self , user_id : UserId , input : RecordConsentInput , ip_address : Option < String > , user_agent : Option < String >) -> Result < ConsentRecord , DbStoreError > { let now = Utc :: now () ; let id = ConsentRecordId :: new () ; let model = consent :: ActiveModel { id : Set (id) , user_id : Set (user_id) , consent_type : Set (match input . consent_type { ConsentType :: TermsOfService => consent :: ConsentType :: TermsOfService , ConsentType :: PrivacyPolicy => consent :: ConsentType :: PrivacyPolicy , ConsentType :: MarketingEmails => consent :: ConsentType :: MarketingEmails , ConsentType :: AiProcessing => consent :: ConsentType :: AiProcessing , ConsentType :: DataSharing => consent :: ConsentType :: DataSharing , ConsentType :: Analytics => consent :: ConsentType :: Analytics , }) , granted : Set (input . granted) , version : Set (input . version . clone ()) , ip_address : Set (ip_address . clone ()) , user_agent : Set (user_agent . clone ()) , created_at : Set (now) , } ; consent :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (ConsentRecord { id : id . as_uuid () , user_id , consent_type : input . consent_type , granted : input . granted , version : input . version , ip_address , user_agent , created_at : now , }) } pub async fn get_consent_records (& self , user_id : UserId) -> Result < Vec < ConsentRecord > , DbStoreError > { let results : Vec < consent :: Model > = consent :: Entity :: find () . filter (consent :: Column :: UserId . eq (user_id)) . order_by_desc (consent :: Column :: CreatedAt) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | ConsentRecord { id : m . id . as_uuid () , user_id : m . user_id , consent_type : match m . consent_type { consent :: ConsentType :: TermsOfService => ConsentType :: TermsOfService , consent :: ConsentType :: PrivacyPolicy => ConsentType :: PrivacyPolicy , consent :: ConsentType :: MarketingEmails => ConsentType :: MarketingEmails , consent :: ConsentType :: AiProcessing => ConsentType :: AiProcessing , consent :: ConsentType :: DataSharing => ConsentType :: DataSharing , consent :: ConsentType :: Analytics => ConsentType :: Analytics , } , granted : m . granted , version : m . version , ip_address : m . ip_address , user_agent : m . user_agent , created_at : m . created_at , }) . collect ()) } pub async fn create_audit_log (& self , input : CreateAuditLogInput) -> Result < AuditLogEntry , DbStoreError > { let now = Utc :: now () ; let id = AuditLogId :: new () ; let model = audit :: ActiveModel { id : Set (id) , user_id : Set (input . user_id) , user_email : Set (input . user_email . clone ()) , action : Set (input . action . clone ()) , resource_type : Set (input . resource_type . clone ()) , resource_id : Set (input . resource_id) , ip_address : Set (input . ip_address . clone ()) , user_agent : Set (input . user_agent . clone ()) , metadata : Set (input . metadata . clone () . unwrap_or_default ()) , success : Set (input . success) , error_message : Set (input . error_message . clone ()) , created_at : Set (now) , } ; audit :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (AuditLogEntry { id : id . as_uuid () , user_id : input . user_id , user_email : input . user_email , action : input . action , resource_type : input . resource_type , resource_id : input . resource_id , ip_address : input . ip_address , user_agent : input . user_agent , metadata : input . metadata . unwrap_or_default () , success : input . success , error_message : input . error_message , created_at : now , }) } pub async fn create_email_invitation (& self , input : CreateEmailInviteInput , invited_by : UserId) -> Result < FamilyInvitation , DbStoreError > { let now = Utc :: now () ; let id = InvitationId :: new () ; let expires_at = Some (now + Duration :: days (input . expires_in_days)) ; let model = invitation :: ActiveModel { id : Set (id) , tenant_id : Set (input . tenant_id) , invited_by : Set (Some (invited_by)) , invite_type : Set (invitation :: InviteType :: Email) , email : Set (Some (input . email . clone ())) , invite_code : Set (None) , role : Set (match input . role . unwrap_or (InviteRole :: Member) { InviteRole :: Admin => invitation :: InviteRole :: Admin , InviteRole :: Member => invitation :: InviteRole :: Member , InviteRole :: Guest => invitation :: InviteRole :: Guest , }) , max_uses : Set (Some (1)) , use_count : Set (0) , expires_at : Set (expires_at) , created_at : Set (now) , } ; invitation :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (FamilyInvitation { id , tenant_id : input . tenant_id , invited_by : Some (invited_by) , invite_type : InviteType :: Email , email : Some (input . email) , invite_code : None , role : input . role . unwrap_or (InviteRole :: Member) , max_uses : 1 , use_count : 0 , expires_at , created_at : now , }) } pub async fn create_code_invitation (& self , input : CreateCodeInviteInput , invited_by : UserId) -> Result < FamilyInvitation , DbStoreError > { let now = Utc :: now () ; let id = InvitationId :: new () ; let code = generate_invite_code () ; let expires_at = input . expires_in_days . map (| days | now + Duration :: days (days)) ; let model = invitation :: ActiveModel { id : Set (id) , tenant_id : Set (input . tenant_id) , invited_by : Set (Some (invited_by)) , invite_type : Set (invitation :: InviteType :: Code) , email : Set (None) , invite_code : Set (Some (code . clone ())) , role : Set (match input . role . unwrap_or (InviteRole :: Member) { InviteRole :: Admin => invitation :: InviteRole :: Admin , InviteRole :: Member => invitation :: InviteRole :: Member , InviteRole :: Guest => invitation :: InviteRole :: Guest , }) , max_uses : Set (Some (input . max_uses)) , use_count : Set (0) , expires_at : Set (expires_at) , created_at : Set (now) , } ; invitation :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (FamilyInvitation { id , tenant_id : input . tenant_id , invited_by : Some (invited_by) , invite_type : InviteType :: Code , email : None , invite_code : Some (code) , role : input . role . unwrap_or (InviteRole :: Member) , max_uses : input . max_uses , use_count : 0 , expires_at , created_at : now , }) } pub async fn get_invitation_by_code (& self , code : & str) -> Result < Option < FamilyInvitation > , DbStoreError > { let result = invitation :: Entity :: find () . filter (invitation :: Column :: InviteCode . eq (code)) . one (& self . db) . await ? ; Ok (result . map (| m | map_invitation (m))) } pub async fn get_invitation_by_email (& self , email : & str , tenant_id : TenantId) -> Result < Option < FamilyInvitation > , DbStoreError > { let result = invitation :: Entity :: find () . filter (invitation :: Column :: Email . eq (email)) . filter (invitation :: Column :: TenantId . eq (tenant_id)) . one (& self . db) . await ? ; Ok (result . map (| m | map_invitation (m))) } pub async fn use_invitation (& self , invitation_id : InvitationId) -> Result < () , DbStoreError > { invitation :: Entity :: update_many () . col_expr (invitation :: Column :: UseCount , Expr :: col (invitation :: Column :: UseCount) . add (1)) . filter (invitation :: Column :: Id . eq (invitation_id)) . exec (& self . db) . await ? ; Ok (()) } pub async fn is_invitation_valid (& self , invitation_id : InvitationId) -> Result < bool , DbStoreError > { let now = Utc :: now () ; let result = invitation :: Entity :: find_by_id (invitation_id) . one (& self . db) . await ? ; match result { None => Ok (false) , Some (inv) => { if inv . expires_at . map (| e | e < now) . unwrap_or (false) { return Ok (false) ; } if inv . use_count >= inv . max_uses . unwrap_or (1) { return Ok (false) ; } Ok (true) } } } pub async fn create_join_request (& self , user_id : UserId , input : CreateJoinRequestInput) -> Result < JoinRequest , DbStoreError > { let now = Utc :: now () ; let id = JoinRequestId :: new () ; let model = join_request :: ActiveModel { id : Set (id) , user_id : Set (user_id) , tenant_id : Set (input . tenant_id) , message : Set (input . message . clone ()) , status : Set (join_request :: JoinRequestStatus :: Pending) , reviewed_by : Set (None) , reviewed_at : Set (None) , review_note : Set (None) , created_at : Set (now) , } ; join_request :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (JoinRequest { id : id . as_uuid () , user_id , tenant_id : input . tenant_id , message : input . message , status : JoinRequestStatus :: Pending , reviewed_by : None , reviewed_at : None , review_note : None , created_at : now , }) } pub async fn get_pending_join_requests (& self , tenant_id : TenantId) -> Result < Vec < JoinRequest > , DbStoreError > { let results : Vec < join_request :: Model > = join_request :: Entity :: find () . filter (join_request :: Column :: TenantId . eq (tenant_id)) . filter (join_request :: Column :: Status . eq (join_request :: JoinRequestStatus :: Pending)) . order_by_desc (join_request :: Column :: CreatedAt) . all (& self . db) . await ? ; Ok (results . into_iter () . map (| m | JoinRequest { id : m . id . as_uuid () , user_id : m . user_id , tenant_id : m . tenant_id , message : m . message , status : match m . status { join_request :: JoinRequestStatus :: Pending => JoinRequestStatus :: Pending , join_request :: JoinRequestStatus :: Approved => JoinRequestStatus :: Approved , join_request :: JoinRequestStatus :: Rejected => JoinRequestStatus :: Rejected , } , reviewed_by : m . reviewed_by , reviewed_at : m . reviewed_at , review_note : m . review_note , created_at : m . created_at , }) . collect ()) } pub async fn review_join_request (& self , request_id : JoinRequestId , reviewer_id : UserId , input : ReviewJoinRequestInput) -> Result < JoinRequest , DbStoreError > { let now = Utc :: now () ; join_request :: Entity :: update_many () . col_expr (join_request :: Column :: Status , Expr :: value (match input . approved { true => "approved" , false => "rejected" , })) . col_expr (join_request :: Column :: ReviewedBy , Expr :: value (Some (reviewer_id))) . col_expr (join_request :: Column :: ReviewedAt , Expr :: value (Some (now))) . col_expr (join_request :: Column :: ReviewNote , Expr :: value (input . note . clone ())) . filter (join_request :: Column :: Id . eq (request_id)) . exec (& self . db) . await ? ; let result = join_request :: Entity :: find_by_id (request_id) . one (& self . db) . await ? . ok_or_else (| | DbStoreError :: not_found ("JoinRequest" , request_id . to_string ())) ? ; Ok (JoinRequest { id : result . id . as_uuid () , user_id : result . user_id , tenant_id : result . tenant_id , message : result . message , status : match result . status { join_request :: JoinRequestStatus :: Pending => JoinRequestStatus :: Pending , join_request :: JoinRequestStatus :: Approved => JoinRequestStatus :: Approved , join_request :: JoinRequestStatus :: Rejected => JoinRequestStatus :: Rejected , } , reviewed_by : result . reviewed_by , reviewed_at : result . reviewed_at , review_note : result . review_note , created_at : result . created_at , }) } pub async fn add_user_to_tenant (& self , user_id : UserId , tenant_id : TenantId , role : InviteRole) -> Result < () , DbStoreError > { let now = Utc :: now () ; let id = UserId :: new () ; let user = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? . ok_or_else (| | DbStoreError :: not_found ("User" , user_id . to_string ())) ? ; let model = tenant_member :: ActiveModel { id : Set (id) , tenant_id : Set (tenant_id) , name : Set (user . name) , email : Set (Some (user . email)) , avatar_url : Set (user . avatar_url) , role : Set (match role { InviteRole :: Admin => tenant_member :: MemberRole :: Admin , InviteRole :: Member => tenant_member :: MemberRole :: Member , InviteRole :: Guest => tenant_member :: MemberRole :: Guest , }) , settings : Set (serde_json :: json ! ({ })) , created_at : Set (now) , updated_at : Set (now) , } ; tenant_member :: Entity :: insert (model) . exec (& self . db) . await ? ; Ok (()) } pub async fn get_user_memberships (& self , user_id : UserId) -> Result < Vec < UserMembership > , DbStoreError > { let user = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? . ok_or_else (| | DbStoreError :: not_found ("User" , user_id . to_string ())) ? ; let results = tenant_member :: Entity :: find () . filter (tenant_member :: Column :: Email . eq (& user . email)) . all (& self . db) . await ? ; let tenant_ids : Vec < TenantId > = results . iter () . map (| m | m . tenant_id) . collect () ; let tenants : std :: collections :: HashMap < TenantId , String > = tenant :: Entity :: find () . filter (tenant :: Column :: Id . is_in (tenant_ids)) . all (& self . db) . await ? . into_iter () . map (| t | (t . id , t . name)) . collect () ; Ok (results . into_iter () . map (| m | UserMembership { tenant_id : m . tenant_id , tenant_name : tenants . get (& m . tenant_id) . cloned () . unwrap_or_default () , role : match m . role { tenant_member :: MemberRole :: Admin => InviteRole :: Admin , tenant_member :: MemberRole :: Member => InviteRole :: Member , tenant_member :: MemberRole :: Guest => InviteRole :: Guest , } , is_primary : user . primary_tenant_id == Some (m . tenant_id) , joined_at : m . created_at , }) . collect ()) } pub async fn is_user_member (& self , user_id : UserId , tenant_id : TenantId) -> Result < bool , DbStoreError > { let user = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? ; match user { None => Ok (false) , Some (u) => { let count = tenant_member :: Entity :: find () . filter (tenant_member :: Column :: TenantId . eq (tenant_id)) . filter (tenant_member :: Column :: Email . eq (& u . email)) . count (& self . db) . await ? ; Ok (count > 0) } } } pub async fn is_user_admin (& self , user_id : UserId , tenant_id : TenantId) -> Result < bool , DbStoreError > { let user = user :: Entity :: find_by_id (user_id) . one (& self . db) . await ? ; match user { None => Ok (false) , Some (u) => { let count = tenant_member :: Entity :: find () . filter (tenant_member :: Column :: TenantId . eq (tenant_id)) . filter (tenant_member :: Column :: Email . eq (& u . email)) . filter (tenant_member :: Column :: Role . eq (tenant_member :: MemberRole :: Admin)) . count (& self . db) . await ? ; Ok (count > 0) } } } }

// Methods: new, from_connection, from_url, from_connection_string, db
impl TigerDataStore { # [doc = " Create a new store with the given configuration"] pub async fn new (config : DbPoolConfig) -> Result < Self , DbStoreError > { let db = sea_orm :: Database :: connect (config . connection . as_str ()) . await . map_err (| e | DbStoreError :: connection (e . to_string ())) ? ; Ok (Self { db }) } # [doc = " Create from an existing SeaORM DatabaseConnection"] # [doc = " "] # [doc = " Useful when you already have a connection and want to wrap it"] # [doc = " in the TigerDataStore interface."] pub fn from_connection (db : DatabaseConnection) -> Self { Self { db } } # [doc = " Create from a connection string"] pub async fn from_url (url : & str) -> Result < Self , DbStoreError > { Self :: from_connection_string (url) . await } # [doc = " Create from a connection string"] pub async fn from_connection_string (url : & str) -> Result < Self , DbStoreError > { let connection = DbConnectionString :: new (url) . map_err (| e | DbStoreError :: connection (e)) ? ; let config = DbPoolConfig :: new (connection) ; Self :: new (config) . await } # [doc = " Get the underlying database connection (SeaORM)"] pub fn db (& self) -> & DatabaseConnection { & self . db } }

// Methods: save_pulse, save_moment, load_pulse, find_similar_by_vector
impl TigerDataStore { pub async fn save_pulse (& self , pulse : & Pulse) -> Result < () , DbStoreError > { let txn = self . db . begin () . await ? ; let now = Utc :: now () ; let entity_id = EntityId :: from (pulse . identity . id . as_uuid ()) ; let tenant_id = TenantId :: from (pulse . identity . tenant_id . as_uuid ()) ; let entity_model = entity_registry :: ActiveModel { id : Set (entity_id) , tenant_id : Set (tenant_id) , entity_type : Set ("Pulse" . to_string ()) , created_at : Set (now) , } ; entity_model . insert (& txn) . await ? ; let p = & pulse . physics ; let excitation_model = field_excitation :: ActiveModel { time : Set (now) , entity_id : Set (entity_id) , pos_valence : Set (p . position [0] . value ()) , pos_arousal : Set (p . position [1] . value ()) , pos_epistemic : Set (p . position [2] . value ()) , vel_valence : Set (p . velocity [0] . value ()) , vel_arousal : Set (p . velocity [1] . value ()) , vel_epistemic : Set (p . velocity [2] . value ()) , amplitude : Set (p . amplitude . value ()) , energy : Set (p . energy . value ()) , temperature : Set (p . temperature . value ()) , } ; excitation_model . insert (& txn) . await ? ; let content_model = content :: ActiveModel { entity_id : Set (entity_id) , text_content : Set (pulse . content . text . clone ()) , metadata : Set (serde_json :: to_value (& pulse . content . metadata) . unwrap_or_default ()) , } ; content_model . insert (& txn) . await ? ; txn . commit () . await ? ; Ok (()) } pub async fn save_moment (& self , moment : & Moment) -> Result < () , DbStoreError > { let txn = self . db . begin () . await ? ; let now = Utc :: now () ; let entity_id = EntityId :: from (moment . identity . id . as_uuid ()) ; let tenant_id = TenantId :: from (moment . identity . tenant_id . as_uuid ()) ; let entity_model = entity_registry :: ActiveModel { id : Set (entity_id) , tenant_id : Set (tenant_id) , entity_type : Set ("Moment" . to_string ()) , created_at : Set (now) , } ; entity_model . insert (& txn) . await ? ; let p = & moment . physics ; let excitation_model = field_excitation :: ActiveModel { time : Set (now) , entity_id : Set (entity_id) , pos_valence : Set (p . position [0] . value ()) , pos_arousal : Set (p . position [1] . value ()) , pos_epistemic : Set (p . position [2] . value ()) , vel_valence : Set (p . velocity [0] . value ()) , vel_arousal : Set (p . velocity [1] . value ()) , vel_epistemic : Set (p . velocity [2] . value ()) , amplitude : Set (p . amplitude . value ()) , energy : Set (p . energy . value ()) , temperature : Set (p . temperature . value ()) , } ; excitation_model . insert (& txn) . await ? ; let amplitudes : Vec < f32 > = moment . quantum . amplitudes . iter () . flat_map (| (re , im) | vec ! [* re as f32 , * im as f32]) . collect () ; let vector_str = format ! ("[{}]" , amplitudes . iter () . map (| a | a . to_string ()) . collect ::< Vec < _ >> () . join (",")) ; txn . execute (Statement :: from_sql_and_values (DbBackend :: Postgres , "INSERT INTO comp_quantum_states (entity_id, amplitudes, coherence, frequency) VALUES ($1, $2::vector, $3, $4)" , vec ! [entity_id . as_uuid () . into () , vector_str . into () , moment . quantum . coherence . value () . into () , moment . quantum . frequency . into ()] ,)) . await ? ; let content_model = content :: ActiveModel { entity_id : Set (entity_id) , text_content : Set (moment . content . text . clone ()) , metadata : Set (serde_json :: to_value (& moment . content . metadata) . unwrap_or_default ()) , } ; content_model . insert (& txn) . await ? ; txn . commit () . await ? ; Ok (()) } pub async fn load_pulse (& self , _entity_id : & UUID) -> Result < Option < Pulse > , DbStoreError > { Ok (None) } # [doc = " Find entities similar to a query vector using pgvector cosine distance"] # [doc = " "] # [doc = " Note: This uses raw SQL because SeaORM doesn't support pgvector natively."] pub async fn find_similar_by_vector (& self , query_vector : Vec < f32 > , limit : i64 ,) -> Result < Vec < (Uuid , f64) > , DbStoreError > { let vector_str = format ! ("[{}]" , query_vector . iter () . map (| a | a . to_string ()) . collect ::< Vec < _ >> () . join (",")) ; let sql = r#"
            SELECT entity_id, 1 - (amplitudes <=> $1::vector) as similarity
            FROM comp_quantum_states
            ORDER BY amplitudes <=> $1::vector
            LIMIT $2
        "# ; let rows = self . db . query_all (Statement :: from_sql_and_values (DbBackend :: Postgres , sql , vec ! [vector_str . into () , limit . into ()] ,)) . await ? ; Ok (rows . into_iter () . map (| r | { let id : Uuid = r . try_get ("" , "entity_id") . unwrap_or_default () ; let sim : f64 = r . try_get ("" , "similarity") . unwrap_or_default () ; (id , sim) }) . collect ()) } }

