//! Impl module for observation_response types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for ObservationResponse

// Methods: from_heddle_response, from_pipeline, is_query, is_log, intent, query_type, query_target, with_raw_response, with_request, with_conversation_debug, with_debug, unit_count, segment_count, is_pipeline, should_spawn_entities
impl ObservationResponse { # [doc = " Create from legacy single-pass HeddleResponse (backward compatible)"] pub fn from_heddle_response (heddle_response : HeddleResponse , metadata : ResponseMetadata) -> Result < Self , String > { let (weave_units , physics_hints , message_intent) = heddle_response . validate () ? ; Ok (Self { segments : vec ! [] , message_intent , classifications : vec ! [] , weave_units , physics_hints , metadata , raw_llm_response : None , llm_request : None , }) } # [doc = " Create from 3-phase pipeline results"] pub fn from_pipeline (segments : Vec < RawSegment > , message_intent : RawMessageIntent , classifications : Vec < SegmentClassification > , metadata : ResponseMetadata ,) -> Self { let mut weave_units = Vec :: new () ; let mut physics_hints = Vec :: new () ; for seg in & segments { let idx = weave_units . len () ; let mut unit = WeaveUnit :: new (idx , seg . content . clone ()) ; if let Some (ref subject) = seg . subject { unit = unit . with_primary_thread (subject . clone ()) ; } if ! seg . mentions . is_empty () { unit = unit . with_secondary_threads (seg . mentions . clone ()) ; } if let Some (ref temporal) = seg . temporal { unit = unit . with_temporal_marker (temporal . clone ()) ; } if let Some (class) = classifications . iter () . find (| c | c . segment_index == idx) { let _ = unit . add_classification (class . entity_type , class . weight) ; let phys = class . physics . as_ref () . map (| p | RawPhysicsHint { valence : p . valence , arousal : p . arousal , significance : p . significance , clarity : p . clarity , intrusiveness : None , volatility : None , }) ; physics_hints . push (phys) ; } else { physics_hints . push (None) ; } weave_units . push (unit) ; } Self { segments , message_intent , classifications , weave_units , physics_hints , metadata , raw_llm_response : None , llm_request : None , } } # [doc = " Check if this is a query/lookup type response"] pub fn is_query (& self) -> bool { self . message_intent . intent . expects_response () } # [doc = " Check if this is a logging type response"] pub fn is_log (& self) -> bool { self . message_intent . intent . stores_data () } # [doc = " Get the message intent"] pub fn intent (& self) -> MessageIntent { self . message_intent . intent } # [doc = " Get query type if this is a QUERY intent"] pub fn query_type (& self) -> Option < QueryType > { self . message_intent . query_type } # [doc = " Get query target if this is a QUERY intent"] pub fn query_target (& self) -> Option < & QueryTarget > { self . message_intent . query_target . as_ref () } # [doc = " Attach the raw LLM output for debugging"] pub fn with_raw_response (mut self , raw : String) -> Self { self . raw_llm_response = Some (raw) ; self } # [doc = " Attach request debug info from prompts"] pub fn with_request (mut self , system : String , user : String) -> Self { self . llm_request = Some (LlmRequestDebug { system_prompt : system , user_prompt : user }) ; self } # [doc = " Attach request debug info directly from a Conversation (schema-first)"] pub fn with_conversation_debug (mut self , conversation : & Conversation) -> Self { self . llm_request = Some (LlmRequestDebug { system_prompt : conversation . system_prompt () , user_prompt : conversation . user_prompt () , }) ; self } # [doc = " Attach both raw response and conversation debug in one call"] pub fn with_debug (self , raw_response : String , conversation : & Conversation) -> Self { self . with_raw_response (raw_response) . with_conversation_debug (conversation) } pub fn unit_count (& self) -> usize { self . weave_units . len () } pub fn segment_count (& self) -> usize { self . segments . len () } # [doc = " Check if this response used the 3-phase pipeline"] pub fn is_pipeline (& self) -> bool { ! self . segments . is_empty () } # [doc = " Should entity spawning happen for this response?"] pub fn should_spawn_entities (& self) -> bool { self . is_log () && ! self . weave_units . is_empty () } }

