//! Impl module for contract_enforcer types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for ContractEnforcer

// Methods: new, compile_schemas_recursive, derive_message_type, unpack, unpack_mut, validate, validate_mut, schema_count, message_types, has_schema, parse_value, parse_value_mut, parse, parse_mut, parse_str, parse_value_str
impl ContractEnforcer { # [doc = " Create a new ContractEnforcer with compiled embedded schemas"] # [doc = ""] # [doc = " This is expensive (~100ms) but only done once at startup."] # [doc = " Panics if embedded schemas are malformed (compile-time guarantee)."] pub fn new () -> Self { let mut validators = HashMap :: new () ; let mut compiled_count = 0 ; let mut errors : Vec < String > = Vec :: new () ; Self :: compile_schemas_recursive (& SCHEMAS , "" , & mut validators , & mut compiled_count , & mut errors) ; # [cfg (debug_assertions)] for err in & errors { eprintln ! ("[ContractEnforcer] {}" , err) ; } Self { validators , schema_count : compiled_count , } } # [doc = " Recursively compile schemas from embedded directory"] fn compile_schemas_recursive (dir : & include_dir :: Dir , prefix : & str , validators : & mut HashMap < String , Arc < Validator > > , count : & mut usize , errors : & mut Vec < String > ,) { for file in dir . files () { let path = file . path () . to_string_lossy () ; if ! path . ends_with (".json") { continue ; } let schema_json : serde_json :: Value = match serde_json :: from_slice (file . contents ()) { Ok (v) => v , Err (e) => { errors . push (format ! ("Invalid JSON in {}: {}" , path , e)) ; continue ; } } ; let message_type = Self :: derive_message_type (& path , prefix) ; match Validator :: new (& schema_json) { Ok (compiled) => { validators . insert (message_type . clone () , Arc :: new (compiled)) ; * count += 1 ; } Err (e) => { errors . push (format ! ("Failed to compile {}: {}" , message_type , e)) ; } } } for subdir in dir . dirs () { let subdir_name = subdir . path () . file_name () . map (| n | n . to_string_lossy () . to_string ()) . unwrap_or_default () ; let new_prefix = if prefix . is_empty () { subdir_name } else { format ! ("{}.{}" , prefix , subdir_name) } ; Self :: compile_schemas_recursive (subdir , & new_prefix , validators , count , errors) ; } } # [doc = " Derive message type from file path"] # [doc = " "] # [doc = " Examples:"] # [doc = " - \"SignupRequest.schema.json\" with prefix \"contracts\" -> \"contracts.SignupRequest\""] # [doc = " - \"pulse.json\" with prefix \"entities\" -> \"entities.pulse\""] fn derive_message_type (path : & str , prefix : & str) -> String { let filename = path . rsplit ('/') . next () . unwrap_or (path) ; let name = filename . trim_end_matches (".json") . trim_end_matches (".schema") ; if prefix . is_empty () { name . to_string () } else { format ! ("{}.{}" , prefix , name) } } # [doc = " Validate and deserialize a payload in one step"] # [doc = ""] # [doc = " This is the primary API for all services. It:"] # [doc = " 1. Looks up the compiled validator for the message type"] # [doc = " 2. Parses the JSON using SIMD-accelerated parser"] # [doc = " 3. Validates against the compiled schema"] # [doc = " 4. Deserializes to the target Rust type"] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `message_type` - The schema identifier (e.g., \"contracts.SignupRequest\")"] # [doc = " * `payload_json` - Raw JSON bytes to validate and parse"] # [doc = ""] # [doc = " # Returns"] # [doc = " * `Ok(T)` - Successfully validated and deserialized value"] # [doc = " * `Err(ContractError)` - Validation or parsing failed"] # [doc = ""] # [doc = " # Example"] # [doc = " ```rust,ignore"] # [doc = " let signup: SignupRequest = enforcer.unpack(\"contracts.SignupRequest\", &bytes)?;"] # [doc = " ```"] # [doc = " Validate and deserialize (convenience method, allocates)"] # [doc = ""] # [doc = " This clones the input buffer. For zero-copy performance, use `unpack_mut`."] pub fn unpack < T : DeserializeOwned > (& self , message_type : & str , payload_json : & [u8] ,) -> Result < T , ContractError > { let mut bytes = payload_json . to_vec () ; self . unpack_mut (message_type , & mut bytes) } # [doc = " Zero-copy validate and deserialize (caller provides mutable buffer)"] # [doc = ""] # [doc = " This is the high-performance API. The caller owns the buffer (typically"] # [doc = " from the Kafka consumer), avoiding allocation overhead on every message."] # [doc = ""] # [doc = " # Performance"] # [doc = " - Saves ~200ns per message by avoiding `to_vec()` clone"] # [doc = " - At 10k msg/sec, this saves ~2ms of allocation per second"] # [doc = ""] # [doc = " # Example"] # [doc = " ```rust,ignore"] # [doc = " // Kafka consumer owns the buffer"] # [doc = " let mut payload = kafka_message.payload_mut();"] # [doc = " let signup: SignupRequest = enforcer.unpack_mut(\"contracts.SignupRequest\", &mut payload)?;"] # [doc = " ```"] pub fn unpack_mut < T : DeserializeOwned > (& self , message_type : & str , payload_json : & mut [u8] ,) -> Result < T , ContractError > { let validator = self . validators . get (message_type) . ok_or_else (| | ContractError :: UnknownType (message_type . to_string ())) ? ; let value : serde_json :: Value = simd_json :: from_slice (payload_json) . map_err (| e | ContractError :: ParseError (e . to_string ())) ? ; let errors : Vec < String > = validator . iter_errors (& value) . map (| e | e . to_string ()) . collect () ; if ! errors . is_empty () { return Err (ContractError :: ValidationFailed { message_type : message_type . to_string () , errors , }) ; } serde_json :: from_value (value) . map_err (| e | ContractError :: ParseError (e . to_string ())) } # [doc = " Validate payload without deserializing (convenience, allocates)"] pub fn validate (& self , message_type : & str , payload_json : & [u8]) -> Result < () , ContractError > { let mut bytes = payload_json . to_vec () ; self . validate_mut (message_type , & mut bytes) } # [doc = " Zero-copy validate without deserializing"] # [doc = ""] # [doc = " Useful when you only need to check validity without parsing to a struct."] pub fn validate_mut (& self , message_type : & str , payload_json : & mut [u8]) -> Result < () , ContractError > { let validator = self . validators . get (message_type) . ok_or_else (| | ContractError :: UnknownType (message_type . to_string ())) ? ; let value : serde_json :: Value = simd_json :: from_slice (payload_json) . map_err (| e | ContractError :: ParseError (e . to_string ())) ? ; let errors : Vec < String > = validator . iter_errors (& value) . map (| e | e . to_string ()) . collect () ; if ! errors . is_empty () { return Err (ContractError :: ValidationFailed { message_type : message_type . to_string () , errors , }) ; } Ok (()) } # [doc = " Get the number of compiled schemas"] pub fn schema_count (& self) -> usize { self . schema_count } # [doc = " List all available message types"] pub fn message_types (& self) -> Vec < & String > { self . validators . keys () . collect () } # [doc = " Check if a message type has a registered schema"] pub fn has_schema (& self , message_type : & str) -> bool { self . validators . contains_key (message_type) } # [doc = " Parse JSON to Value (convenience, allocates)"] pub fn parse_value (& self , payload_json : & [u8]) -> Result < serde_json :: Value , ContractError > { let mut bytes = payload_json . to_vec () ; self . parse_value_mut (& mut bytes) } # [doc = " Zero-copy parse JSON to Value using SIMD acceleration (no validation)"] # [doc = ""] # [doc = " Use this for internal pipeline communication where data has already"] # [doc = " been validated at the entry point. 3x faster than serde_json."] pub fn parse_value_mut (& self , payload_json : & mut [u8]) -> Result < serde_json :: Value , ContractError > { simd_json :: from_slice (payload_json) . map_err (| e | ContractError :: ParseError (e . to_string ())) } # [doc = " Parse JSON to typed struct (convenience, allocates)"] pub fn parse < T : DeserializeOwned > (& self , payload_json : & [u8]) -> Result < T , ContractError > { let mut bytes = payload_json . to_vec () ; self . parse_mut (& mut bytes) } # [doc = " Zero-copy parse JSON to typed struct using SIMD acceleration (no validation)"] # [doc = ""] # [doc = " Use this for internal pipeline communication where validation is"] # [doc = " not required. Falls back to fast SIMD parsing without schema checks."] pub fn parse_mut < T : DeserializeOwned > (& self , payload_json : & mut [u8]) -> Result < T , ContractError > { simd_json :: from_slice (payload_json) . map_err (| e | ContractError :: ParseError (e . to_string ())) } # [doc = " Parse JSON string to typed struct (convenience for &str input)"] pub fn parse_str < T : DeserializeOwned > (& self , payload_json : & str) -> Result < T , ContractError > { self . parse (payload_json . as_bytes ()) } # [doc = " Parse JSON string to Value (convenience for &str input)"] pub fn parse_value_str (& self , payload_json : & str) -> Result < serde_json :: Value , ContractError > { self . parse_value (payload_json . as_bytes ()) } }

// Trait impl: Default
impl Default for ContractEnforcer { fn default () -> Self { Self :: new () } }

