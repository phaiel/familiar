//! Impl module for shuttle types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for Shuttle

// Methods: new, with_context, with_provider, add_unit, add_unit_with_details, start_processing, start_classifying, start_spawning, complete, fail, is_terminal, is_complete, unit_count, total_spawned, all_classified, get_unit_mut, units, units_mut, raw_input, context
impl Shuttle { # [doc = " Create a new shuttle for a course with a weave"] pub fn new (course_id : UUID , weave : impl Into < Weave >) -> Self { Self { id : UUID :: new () , course_id , status : ShuttleStatus :: Pending , weave : weave . into () , details : ShuttleDetails :: new () , units : vec ! [] , response : None , created_at : Timestamp :: now () , started_at : None , completed_at : None , error : None , } } # [doc = " Set context on the weave"] pub fn with_context (mut self , context : impl Into < String >) -> Self { self . weave = self . weave . with_context (context) ; self } # [doc = " Set provider and model in details"] pub fn with_provider (mut self , provider : impl Into < String > , model : impl Into < String >) -> Self { self . details = self . details . with_provider (provider) . with_model (model) ; self } # [doc = " Add a weave unit to the shuttle"] pub fn add_unit (& mut self , content : impl Into < String >) -> & mut WeaveUnit { let index = self . units . len () ; self . units . push (WeaveUnit :: new (index , content)) ; self . units . last_mut () . unwrap () } # [doc = " Add a weave unit with threads, temporal marker, and classifications"] pub fn add_unit_with_details (& mut self , content : impl Into < String > , primary_thread : Option < String > , secondary_threads : Vec < String > , temporal_marker : Option < String > , classifications : Vec < (HeddleEntityType , f64) > ,) -> Result < & mut WeaveUnit , String > { let index = self . units . len () ; let mut unit = WeaveUnit :: new (index , content) ; if let Some (thread) = primary_thread { unit = unit . with_primary_thread (thread) ; } if ! secondary_threads . is_empty () { unit = unit . with_secondary_threads (secondary_threads) ; } if let Some (marker) = temporal_marker { unit = unit . with_temporal_marker (marker) ; } for (entity_type , weight) in classifications { unit . add_classification (entity_type , weight) ? ; } self . units . push (unit) ; Ok (self . units . last_mut () . unwrap ()) } # [doc = " Start processing (receiving -> segmenting)"] pub fn start_processing (& mut self) { self . status = ShuttleStatus :: Classifying ; self . started_at = Some (Timestamp :: now ()) ; } # [doc = " Start classifying"] pub fn start_classifying (& mut self) { self . status = ShuttleStatus :: Classifying ; } # [doc = " Start spawning entities"] pub fn start_spawning (& mut self) { self . status = ShuttleStatus :: Spawning ; self . details . set_unit_count (self . units . len ()) ; } # [doc = " Mark as complete with response"] pub fn complete (& mut self , response : impl Into < String >) { self . response = Some (response . into ()) ; self . status = ShuttleStatus :: Complete ; self . completed_at = Some (Timestamp :: now ()) ; self . details . set_spawn_count (self . total_spawned ()) ; if let Some (started) = & self . started_at { if let Some (completed) = & self . completed_at { let latency = (* completed - * started) . num_milliseconds () as u64 ; self . details . set_latency (latency) ; } } } # [doc = " Mark as failed"] pub fn fail (& mut self , error : impl Into < String >) { self . status = ShuttleStatus :: Failed ; self . error = Some (error . into ()) ; self . completed_at = Some (Timestamp :: now ()) ; } # [doc = " Check if processing is complete (success or failure)"] pub fn is_terminal (& self) -> bool { self . status . is_terminal () } # [doc = " Check if shuttle completed successfully"] pub fn is_complete (& self) -> bool { self . status == ShuttleStatus :: Complete } # [doc = " Get the number of weave units"] pub fn unit_count (& self) -> usize { self . units . len () } # [doc = " Get total spawned entities across all units"] pub fn total_spawned (& self) -> usize { self . units . iter () . map (| u | u . spawned_entity_ids . len ()) . sum () } # [doc = " Check if all units have been classified"] pub fn all_classified (& self) -> bool { ! self . units . is_empty () && self . units . iter () . all (| u | u . is_classified ()) } # [doc = " Get a mutable reference to a unit by index"] pub fn get_unit_mut (& mut self , index : usize) -> Option < & mut WeaveUnit > { self . units . get_mut (index) } # [doc = " Iterate over units"] pub fn units (& self) -> impl Iterator < Item = & WeaveUnit > { self . units . iter () } # [doc = " Iterate over units mutably"] pub fn units_mut (& mut self) -> impl Iterator < Item = & mut WeaveUnit > { self . units . iter_mut () } # [doc = " Get the raw input from the weave"] pub fn raw_input (& self) -> & str { & self . weave . raw_content } # [doc = " Get the context from the weave"] pub fn context (& self) -> Option < & str > { self . weave . context . as_deref () } }

