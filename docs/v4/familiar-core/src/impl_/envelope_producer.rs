//! Impl module for envelope_producer types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for EnvelopeProducer

// Methods: new, send, send_to_topic, send_envelope, send_command
impl EnvelopeProducer { # [doc = " Create a new envelope producer"] pub fn new (brokers : & str) -> Result < Self , rdkafka :: error :: KafkaError > { let producer : FutureProducer = ClientConfig :: new () . set ("bootstrap.servers" , brokers) . set ("message.timeout.ms" , "5000") . set ("acks" , "all") . set ("enable.idempotence" , "true") . create () ? ; Ok (Self { producer : Arc :: new (producer) , }) } # [doc = " Send any serializable payload - zero mapping code"] # [doc = ""] # [doc = " The payload is serialized to JSON bytes and wrapped in a Protobuf envelope."] # [doc = " Kafka can route on `message_type` and `tenant_id` without parsing the payload."] # [doc = ""] # [doc = " # Arguments"] # [doc = " - `topic`: Kafka topic to send to"] # [doc = " - `message_type`: Message type for routing (e.g., \"onboarding.signup\")"] # [doc = " - `tenant_id`: Tenant (family) context"] # [doc = " - `course_id`: Session context (persistent history bucket)"] # [doc = " - `shuttle_id`: Job context (transient unit of work)"] # [doc = " - `payload`: Any serializable type"] pub async fn send < T : Serialize > (& self , topic : & str , message_type : & str , tenant_id : & str , course_id : & str , shuttle_id : & str , payload : & T ,) -> Result < () , ProducerError > { let payload_json = serde_json :: to_vec (payload) . map_err (| e | ProducerError :: Serialization (e . to_string ())) ? ; let envelope = EnvelopeV1 { message_id : ulid :: Ulid :: new () . to_string () , tenant_id : tenant_id . to_string () , course_id : course_id . to_string () , shuttle_id : shuttle_id . to_string () , message_type : message_type . to_string () , payload_json , } ; let bytes = envelope . encode_to_vec () ; let key = format ! ("{}:{}" , tenant_id , course_id) ; let headers = OwnedHeaders :: new () . insert (rdkafka :: message :: Header { key : "message_type" , value : Some (message_type . as_bytes ()) , }) . insert (rdkafka :: message :: Header { key : "course_id" , value : Some (course_id . as_bytes ()) , }) . insert (rdkafka :: message :: Header { key : "tenant_id" , value : Some (tenant_id . as_bytes ()) , }) . insert (rdkafka :: message :: Header { key : "content_type" , value : Some (b"application/x-protobuf") , }) ; let record = FutureRecord :: to (topic) . key (& key) . headers (headers) . payload (& bytes) ; self . producer . send (record , Timeout :: After (Duration :: from_secs (5))) . await . map_err (| (e , _) | ProducerError :: Kafka (e . to_string ())) ? ; Ok (()) } # [doc = " Send to a specific topic (convenience method)"] # [doc = " Generates new course_id and shuttle_id automatically"] pub async fn send_to_topic < T : Serialize > (& self , topic : & str , message_type : & str , tenant_id : & str , payload : & T ,) -> Result < () , ProducerError > { let course_id = ulid :: Ulid :: new () . to_string () ; let shuttle_id = ulid :: Ulid :: new () . to_string () ; self . send (topic , message_type , tenant_id , & course_id , & shuttle_id , payload) . await } # [doc = " Send an already-constructed JSON envelope"] # [doc = ""] # [doc = " This is a convenience method for API services that have already built"] # [doc = " the JSON EnvelopeV1 type. The envelope is serialized and wrapped in"] # [doc = " the Protobuf wire format."] pub async fn send_envelope (& self , topic : & str , envelope : & crate :: types :: contracts :: envelope :: EnvelopeV1 ,) -> Result < () , ProducerError > { let payload_json = serde_json :: to_vec (& envelope . payload) . map_err (| e | ProducerError :: Serialization (e . to_string ())) ? ; let tenant_id = envelope . tenant_id . to_string () ; let course_id = envelope . course_id . map (| c | c . to_string ()) . unwrap_or_else (| | envelope . correlation_id . clone ()) ; let shuttle_id = envelope . shuttle_id . map (| s | s . to_string ()) . unwrap_or_else (| | ulid :: Ulid :: new () . to_string ()) ; let proto_envelope = EnvelopeV1 { message_id : envelope . message_id . clone () , tenant_id : tenant_id . clone () , course_id : course_id . clone () , shuttle_id : shuttle_id . clone () , message_type : envelope . message_type . clone () , payload_json , } ; let bytes = proto_envelope . encode_to_vec () ; let key = format ! ("{}:{}" , tenant_id , course_id) ; let headers = OwnedHeaders :: new () . insert (rdkafka :: message :: Header { key : "message_type" , value : Some (envelope . message_type . as_bytes ()) , }) . insert (rdkafka :: message :: Header { key : "course_id" , value : Some (course_id . as_bytes ()) , }) . insert (rdkafka :: message :: Header { key : "tenant_id" , value : Some (tenant_id . as_bytes ()) , }) . insert (rdkafka :: message :: Header { key : "content_type" , value : Some (b"application/x-protobuf") , }) ; let record = FutureRecord :: to (topic) . key (& key) . headers (headers) . payload (& bytes) ; self . producer . send (record , Timeout :: After (Duration :: from_secs (5))) . await . map_err (| (e , _) | ProducerError :: Kafka (e . to_string ())) ? ; Ok (()) } # [doc = " Legacy alias for send_envelope (deprecated)"] # [deprecated (since = "0.2.0" , note = "Use send_envelope instead")] pub async fn send_command (& self , envelope : & crate :: types :: contracts :: envelope :: EnvelopeV1 ,) -> Result < () , ProducerError > { self . send_envelope ("familiar.commands" , envelope) . await } }

// Trait impl: Clone
impl Clone for EnvelopeProducer { fn clone (& self) -> Self { Self { producer : Arc :: clone (& self . producer) , } } }

