//! Impl module for kafka_analyzer types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for KafkaAnalyzer

// Methods: new, analyze, check_kafka_types, check_schema_derives, check_manual_implementations, check_serialization_format
impl KafkaAnalyzer { pub fn new (root : PathBuf) -> Self { let envelope_types : HashSet < & 'static str > = ["EnvelopeV1" , "Payload" , "TraceKind" , "TraceStatus" , "TracePayload" ,] . into_iter () . collect () ; Self { root , envelope_types , } } # [doc = " Run Kafka-specific analysis"] pub fn analyze (& self , files : & [PathBuf]) -> Vec < Issue > { let issues = Mutex :: new (Vec :: new ()) ; self . check_kafka_types (& issues) ; self . check_manual_implementations (files , & issues) ; self . check_serialization_format (files , & issues) ; issues . into_inner () . unwrap () } # [doc = " Check that all Kafka envelope types have Protobuf schema definitions"] fn check_kafka_types (& self , issues : & Mutex < Vec < Issue > >) { let kafka_dir = self . root . join ("familiar-core/src/types/kafka") ; if ! kafka_dir . exists () { return ; } let files = ["command.rs" , "event.rs" , "trace.rs"] ; for file_name in files { let file_path = kafka_dir . join (file_name) ; if let Ok (content) = fs :: read_to_string (& file_path) { self . check_schema_derives (& content , & file_path , issues) ; } } } # [doc = " Check a file for missing Protobuf schema definitions for Kafka types"] # [doc = " "] # [doc = " Note: We use Protobuf (not JSON Schema) for serialization because:"] # [doc = " - Protobuf provides compact binary encoding with strong typing"] # [doc = " - Schema Registry supports Protobuf schemas"] # [doc = " - Generated code provides type-safe serialization/deserialization"] fn check_schema_derives (& self , content : & str , file_path : & PathBuf , issues : & Mutex < Vec < Issue > >) { let type_re = Regex :: new (r"(?ms)((?:#\[[^\]]+\]\s*)*)(pub\s+(?:struct|enum)\s+(\w+))") . unwrap () ; let serde_re = Regex :: new (r"derive\([^)]*Serialize.*Deserialize|derive\([^)]*Deserialize.*Serialize") . unwrap () ; for cap in type_re . captures_iter (content) { let type_name = cap . get (3) . map (| m | m . as_str ()) . unwrap_or ("") ; if ! self . envelope_types . contains (type_name) { continue ; } let attrs = cap . get (1) . map (| m | m . as_str ()) . unwrap_or ("") ; let line = content [.. cap . get (0) . unwrap () . start ()] . lines () . count () + 1 ; if ! serde_re . is_match (attrs) { issues . lock () . unwrap () . push (Issue { file : file_path . clone () , line , kind : IssueKind :: MissingProtobufSchema { type_name : type_name . to_string () , file : file_path . display () . to_string () , } , severity : Severity :: Error , message : format ! ("Kafka envelope type '{}' is missing #[derive(Serialize, Deserialize, schemars::JsonSchema)] for JSON encoding" , type_name) , fix : Some (Fix { description : format ! ("Add Serialize, Deserialize to derive macro for {}" , type_name) , replacement : Some ("Serialize, Deserialize" . to_string ()) , }) , }) ; } } } # [doc = " Check services for deprecated manual Kafka implementations"] fn check_manual_implementations (& self , files : & [PathBuf] , issues : & Mutex < Vec < Issue > >) { let deprecated_patterns = [(r"#\[deprecated.*Use generated.*Producer" , "CommandProducer" , "CourseCommandProducer") , (r"#\[deprecated.*Use generated.*Consumer" , "TraceConsumer" , "CourseTraceConsumer") , (r"impl\s+CommandProducer" , "CommandProducer" , "CourseCommandProducer") , (r"impl\s+TraceConsumer" , "TraceConsumer" , "CourseTraceConsumer") , (r"impl\s+EventProducer" , "EventProducer" , "CourseEventProducer") , (r"impl\s+CommandConsumer" , "CommandConsumer" , "CourseCommandConsumer") ,] ; files . par_iter () . for_each (| path | { let path_str = path . display () . to_string () ; if ! path_str . contains ("services/") || ! path_str . contains ("/kafka/") { return ; } if let Ok (content) = fs :: read_to_string (path) { for (pattern , component , replacement) in & deprecated_patterns { if let Ok (re) = Regex :: new (pattern) { if re . is_match (& content) { let line = content . lines () . enumerate () . find (| (_ , line) | re . is_match (line)) . map (| (i , _) | i + 1) . unwrap_or (1) ; issues . lock () . unwrap () . push (Issue { file : path . clone () , line , kind : IssueKind :: ManualKafkaImplementation { component : component . to_string () , file : path_str . clone () , suggested_replacement : format ! ("familiar_core::kafka::clients::{}" , replacement) , } , severity : Severity :: Warning , message : format ! ("Manual {} should be replaced with generated {}" , component , replacement) , fix : Some (Fix { description : format ! ("Use familiar_core::kafka::clients::{} instead" , replacement) , replacement : None , }) , }) ; } } } } }) ; } # [doc = " Check for JSON serialization when Protobuf should be used"] fn check_serialization_format (& self , files : & [PathBuf] , issues : & Mutex < Vec < Issue > >) { let json_patterns = [(r"serde_json::to_string\(&envelope" , "JSON serialization for Kafka envelope") , (r"serde_json::from_str.*EnvelopeV1" , "JSON deserialization for Kafka envelope") , (r"send_command\(&envelope" , "Sending command via EnvelopeProducer") , (r"send_event\(&envelope" , "Sending event via EnvelopeProducer") , (r"send_trace\(&envelope" , "Sending trace via EnvelopeProducer") ,] ; files . par_iter () . for_each (| path | { let path_str = path . display () . to_string () ; if ! path_str . contains ("services/") || ! path_str . contains ("/kafka/") { return ; } if let Ok (content) = fs :: read_to_string (path) { for (pattern , description) in & json_patterns { if let Ok (re) = Regex :: new (pattern) { if re . is_match (& content) { let line = content . lines () . enumerate () . find (| (_ , line) | re . is_match (line)) . map (| (i , _) | i + 1) . unwrap_or (1) ; issues . lock () . unwrap () . push (Issue { file : path . clone () , line , kind : IssueKind :: JsonSerializationInsteadOfProtobuf { component : description . to_string () , file : path_str . clone () , } , severity : Severity :: Info , message : format ! ("{} - should use Protobuf serialization via ProtobufSerializer" , description) , fix : Some (Fix { description : "Use ProtobufSerializer.encode_with_schema_id() instead" . to_string () , replacement : None , }) , }) ; } } } } }) ; } }

