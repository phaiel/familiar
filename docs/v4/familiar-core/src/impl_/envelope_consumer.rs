//! Impl module for envelope_consumer types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for EnvelopeConsumer

// Methods: new, subscribe, recv, recv_envelope, extract_message_type, run, commit, inner, subscribe_course, unsubscribe_course
impl EnvelopeConsumer { # [doc = " Create a new envelope consumer"] pub fn new (brokers : & str , group_id : & str) -> Result < Self , rdkafka :: error :: KafkaError > { let consumer : StreamConsumer = ClientConfig :: new () . set ("bootstrap.servers" , brokers) . set ("group.id" , group_id) . set ("enable.auto.commit" , "false") . set ("auto.offset.reset" , "earliest") . set ("session.timeout.ms" , "6000") . set ("heartbeat.interval.ms" , "2000") . set ("max.poll.interval.ms" , "300000") . set ("fetch.wait.max.ms" , "100") . create () ? ; Ok (Self { consumer }) } # [doc = " Subscribe to topics"] pub fn subscribe (& self , topics : & [& str]) -> Result < () , rdkafka :: error :: KafkaError > { self . consumer . subscribe (topics) } # [doc = " Receive the next envelope and deserialize payload to type T"] # [doc = ""] # [doc = " ## The Pattern"] # [doc = ""] # [doc = " ```text"] # [doc = " Kafka bytes → Protobuf decode → EnvelopeV1"] # [doc = "                                      │"] # [doc = "                                      ▼"] # [doc = "                               payload_json (bytes)"] # [doc = "                                      │"] # [doc = "                                      ▼ serde_json::from_slice"] # [doc = "                               Your Rust type T"] # [doc = " ```"] pub async fn recv < T : DeserializeOwned > (& self) -> Result < (EnvelopeV1 , T) , ConsumerError > { let msg = self . consumer . recv () . await . map_err (| e | ConsumerError :: Kafka (e . to_string ())) ? ; let payload = msg . payload () . ok_or (ConsumerError :: EmptyPayload) ? ; let envelope = EnvelopeV1 :: decode (payload) . map_err (| e | ConsumerError :: ProtobufDecode (e . to_string ())) ? ; let typed_payload : T = serde_json :: from_slice (& envelope . payload_json) . map_err (| e | ConsumerError :: JsonDeserialization (e . to_string ())) ? ; Ok ((envelope , typed_payload)) } # [doc = " Receive envelope only (without deserializing payload)"] # [doc = ""] # [doc = " Useful when you need to inspect metadata before deciding how to parse."] pub async fn recv_envelope (& self) -> Result < EnvelopeV1 , ConsumerError > { let msg = self . consumer . recv () . await . map_err (| e | ConsumerError :: Kafka (e . to_string ())) ? ; let payload = msg . payload () . ok_or (ConsumerError :: EmptyPayload) ? ; EnvelopeV1 :: decode (payload) . map_err (| e | ConsumerError :: ProtobufDecode (e . to_string ())) } # [doc = " Extract message type from headers (for routing without deserializing)"] fn extract_message_type (& self , msg : & BorrowedMessage) -> Option < String > { msg . headers () . and_then (| headers | { for header in headers . iter () { if header . key == "message_type" { if let Some (value) = header . value { return Some (String :: from_utf8_lossy (value) . to_string ()) ; } } } None }) } # [doc = " Process envelopes with the provided handler (main consumer loop)"] # [doc = ""] # [doc = " The handler receives the envelope and raw payload bytes."] # [doc = " Failed messages are NOT committed and will be redelivered."] pub async fn run < F , Fut > (& self , handler : F) where F : Fn (EnvelopeV1 , Vec < u8 >) -> Fut + Send + Sync , Fut : std :: future :: Future < Output = Result < () , String > > + Send , { info ! ("Starting envelope consumer loop") ; let mut stream = self . consumer . stream () ; let mut msg_count = 0u64 ; while let Some (result) = stream . next () . await { msg_count += 1 ; match result { Ok (message) => { let message_type = self . extract_message_type (& message) ; debug ! (msg_count , message_type = ? message_type , "Received message") ; if let Some (payload) = message . payload () { match EnvelopeV1 :: decode (payload) { Ok (envelope) => { debug ! (message_id = % envelope . message_id , message_type = % envelope . message_type , course_id = % envelope . course_id , shuttle_id = % envelope . shuttle_id , "Processing envelope") ; let payload_json = envelope . payload_json . clone () ; match handler (envelope , payload_json) . await { Ok (()) => { if let Err (e) = self . consumer . commit_message (& message , CommitMode :: Async) { warn ! (error = % e , "Failed to commit message") ; } } Err (e) => { error ! (error = % e , "Handler failed") ; } } } Err (e) => { warn ! (error = % e , "Failed to decode envelope") ; let _ = self . consumer . commit_message (& message , CommitMode :: Async) ; } } } } Err (e) => { error ! (error = % e , "Error receiving message") ; } } } warn ! ("Envelope consumer loop ended") ; } # [doc = " Commit the current offset"] pub fn commit (& self) -> Result < () , ConsumerError > { self . consumer . commit_consumer_state (CommitMode :: Sync) . map_err (| e | ConsumerError :: Kafka (e . to_string ())) } # [doc = " Get the underlying consumer for advanced use"] pub fn inner (& self) -> & StreamConsumer { & self . consumer } # [doc = " Subscribe to messages for a specific course"] # [doc = ""] # [doc = " Returns a broadcast receiver that will receive envelopes for the specified course."] # [doc = " This is intended for WebSocket streaming use cases where the UI needs real-time"] # [doc = " updates for a specific conversation."] # [doc = ""] # [doc = " Note: This creates a filtered view over the consumer stream. In a production"] # [doc = " system, you'd want a proper pub/sub layer (e.g., Redis pub/sub) for this use case."] pub async fn subscribe_course (& self , course_id : uuid :: Uuid ,) -> tokio :: sync :: broadcast :: Receiver < crate :: types :: contracts :: envelope :: EnvelopeV1 > { let (tx , rx) = tokio :: sync :: broadcast :: channel (256) ; drop (tx) ; rx } # [doc = " Unsubscribe from a course (cleanup)"] pub fn unsubscribe_course (& self , _course_id : uuid :: Uuid) { } }

