//! Impl module for communication_analyzer types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for CommunicationAnalyzer

// Methods: new, analyze, check_cargo_dependencies, check_dependencies_in_toml, check_source_files, service_from_path, get_summary
impl CommunicationAnalyzer { pub fn new (root : PathBuf) -> Self { let services_dir = root . join ("services") ; let service_paths = if services_dir . exists () { fs :: read_dir (& services_dir) . map (| entries | { entries . filter_map (| e | e . ok ()) . map (| e | e . path ()) . filter (| p | p . is_dir ()) . collect () }) . unwrap_or_default () } else { Vec :: new () } ; Self { root , service_paths } } # [doc = " Run communication pattern analysis"] pub fn analyze (& self , files : & [PathBuf]) -> Vec < Issue > { let issues = Mutex :: new (Vec :: new ()) ; self . check_cargo_dependencies (& issues) ; self . check_source_files (files , & issues) ; issues . into_inner () . unwrap () } # [doc = " Check Cargo.toml files for HTTP dependencies in worker services"] fn check_cargo_dependencies (& self , issues : & Mutex < Vec < Issue > >) { for service_path in & self . service_paths { let service_name = service_path . file_name () . and_then (| n | n . to_str ()) . unwrap_or ("unknown") ; if ALLOWED_HTTP_SERVICES . contains (& service_name) { continue ; } let cargo_path = service_path . join ("Cargo.toml") ; if ! cargo_path . exists () { continue ; } if let Ok (content) = fs :: read_to_string (& cargo_path) { if let Ok (toml) = content . parse :: < Value > () { self . check_dependencies_in_toml (& toml , & cargo_path , service_name , issues ,) ; } } } } # [doc = " Check a Cargo.toml for HTTP-related dependencies"] fn check_dependencies_in_toml (& self , toml : & Value , cargo_path : & PathBuf , service_name : & str , issues : & Mutex < Vec < Issue > > ,) { let check_deps = | deps : Option < & Value > | { if let Some (Value :: Table (deps_table)) = deps { for (dep_name , _) in deps_table . iter () { if HTTP_DEPENDENCIES . iter () . any (| d | * d == dep_name) { if WORKER_SERVICES . contains (& service_name) { issues . lock () . unwrap () . push (Issue { file : cargo_path . clone () , line : 1 , kind : IssueKind :: DirectHttpInWorker { component : format ! ("{} dependency" , dep_name) , file : cargo_path . display () . to_string () , suggested_alternative : "Remove HTTP dependency - use Kafka EnvelopeProducer/Consumer" . to_string () , } , severity : Severity :: Warning , message : format ! ("Worker service '{}' has HTTP dependency '{}' - workers should use Kafka for communication" , service_name , dep_name) , fix : Some (Fix { description : format ! ("Remove '{}' from Cargo.toml and migrate to Kafka-based communication" , dep_name) , replacement : None , }) , }) ; } } } } } ; check_deps (toml . get ("dependencies")) ; } # [doc = " Check source files for HTTP patterns"] fn check_source_files (& self , files : & [PathBuf] , issues : & Mutex < Vec < Issue > >) { let http_patterns = [("reqwest::Client" , "reqwest HTTP client") , ("hyper::Client" , "hyper HTTP client") , ("http_client.post" , "HTTP POST call") , ("http_client.get" , "HTTP GET call") , (".send().await" , "async HTTP request") ,] ; files . par_iter () . for_each (| path | { let path_str = path . display () . to_string () ; let service_name = self . service_from_path (& path_str) ; if let Some (name) = & service_name { if ALLOWED_HTTP_SERVICES . contains (& name . as_str ()) { return ; } } if ! path_str . contains ("familiar-worker") { return ; } if let Ok (content) = fs :: read_to_string (path) { for (pattern , description) in & http_patterns { if content . contains (pattern) { let line = content . lines () . enumerate () . find (| (_ , line) | line . contains (pattern)) . map (| (i , _) | i + 1) . unwrap_or (1) ; issues . lock () . unwrap () . push (Issue { file : path . clone () , line , kind : IssueKind :: DirectHttpInWorker { component : description . to_string () , file : path_str . clone () , suggested_alternative : "EnvelopeProducer.send_command()" . to_string () , } , severity : Severity :: Error , message : format ! ("{} in worker service - use Kafka EnvelopeProducer instead" , description) , fix : Some (Fix { description : "Replace HTTP call with Kafka message" . to_string () , replacement : None , }) , }) ; } } } }) ; } # [doc = " Extract service name from file path"] fn service_from_path (& self , path : & str) -> Option < String > { if path . contains ("familiar-api") { Some ("familiar-api" . to_string ()) } else if path . contains ("familiar-worker") { Some ("familiar-worker" . to_string ()) } else if path . contains ("familiar-ui") { Some ("familiar-ui" . to_string ()) } else { None } } # [doc = " Get a summary of communication patterns found"] pub fn get_summary (& self , issues : & [Issue]) -> CommunicationSummary { let mut summary = CommunicationSummary :: default () ; for issue in issues { match & issue . kind { IssueKind :: DirectHttpInWorker { .. } => { summary . http_in_workers += 1 ; } IssueKind :: HttpClientInWorkerStruct { .. } => { summary . http_client_fields += 1 ; } IssueKind :: InterServiceBypassKafka { .. } => { summary . kafka_bypasses += 1 ; } _ => { } } } summary . total_violations = summary . http_in_workers + summary . http_client_fields + summary . kafka_bypasses ; summary . compliant = summary . total_violations == 0 ; summary } }

