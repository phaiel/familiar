//! Impl module for weave_unit types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for WeaveUnit

// Methods: new, with_purpose, with_primary_thread, with_secondary_threads, with_temporal_marker, add_secondary_thread, with_thread_hint, all_threads, add_classification, add_spawned, dominant_classification, classifications_above, is_classified, should_spawn, has_spawned, spawn_count
impl WeaveUnit { pub fn new (index : usize , content : impl Into < String >) -> Self { Self { index , content : content . into () , purpose : MessageIntent :: Log , primary_thread : None , secondary_threads : vec ! [] , temporal_marker : None , classifications : vec ! [] , spawned_entity_ids : vec ! [] , } } pub fn with_purpose (mut self , purpose : MessageIntent) -> Self { self . purpose = purpose ; self } pub fn with_primary_thread (mut self , thread : impl Into < String >) -> Self { self . primary_thread = Some (thread . into ()) ; self } pub fn with_secondary_threads (mut self , threads : Vec < String >) -> Self { self . secondary_threads = threads ; self } pub fn with_temporal_marker (mut self , marker : impl Into < String >) -> Self { self . temporal_marker = Some (marker . into ()) ; self } pub fn add_secondary_thread (& mut self , thread : impl Into < String >) { self . secondary_threads . push (thread . into ()) ; } # [doc = " Legacy alias for backward compatibility"] pub fn with_thread_hint (self , hint : impl Into < String >) -> Self { self . with_primary_thread (hint) } # [doc = " Get all threads (primary + secondary)"] pub fn all_threads (& self) -> Vec < & str > { let mut threads = Vec :: new () ; if let Some (p) = & self . primary_thread { threads . push (p . as_str ()) ; } threads . extend (self . secondary_threads . iter () . map (| s | s . as_str ())) ; threads } pub fn add_classification (& mut self , entity_type : HeddleEntityType , weight : f64) -> Result < () , String > { let weight = NormalizedFloat :: new (weight) ? ; self . classifications . push (WeaveUnitClassification { entity_type , weight }) ; Ok (()) } pub fn add_spawned (& mut self , entity_id : UUID) { self . spawned_entity_ids . push (entity_id) ; } # [doc = " Get the dominant classification (highest weight)"] pub fn dominant_classification (& self) -> Option < & WeaveUnitClassification > { self . classifications . iter () . max_by (| a , b | a . weight . value () . partial_cmp (& b . weight . value ()) . unwrap ()) } # [doc = " Get classifications above a threshold (for superposition collapse)"] pub fn classifications_above (& self , threshold : f64) -> Vec < & WeaveUnitClassification > { self . classifications . iter () . filter (| c | c . weight . value () >= threshold) . collect () } # [doc = " Check if this unit has any classifications"] pub fn is_classified (& self) -> bool { ! self . classifications . is_empty () } # [doc = " Check if this unit should spawn entities (only LOG purpose units do)"] pub fn should_spawn (& self) -> bool { self . purpose == MessageIntent :: Log && self . is_classified () } # [doc = " Check if entities have been spawned from this unit"] pub fn has_spawned (& self) -> bool { ! self . spawned_entity_ids . is_empty () } # [doc = " Get the number of spawned entities"] pub fn spawn_count (& self) -> usize { self . spawned_entity_ids . len () } }

