//! Impl module for course types
//!
//! This module contains behavior for generated types.
//! The types are imported from familiar-contracts.

use familiar_contracts::prelude::*;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

// Impl blocks for Course

// Methods: new, with_title, commit_message, commit_user_message, commit_user_message_with_shuttle, commit_assistant_message, commit_assistant_message_with_shuttle, commit_system_message, set_active, set_idle, archive, last_message, message_count, is_empty, generate_preview, to_summary, get_history_for_context, get_history_for_context_tokens, get_history_with_token_info, recalculate_token_count
impl Course { # [doc = " Create a new empty course"] pub fn new (tenant_id : UUID) -> Self { let now = Timestamp :: now () ; Self { id : UUID :: new () , tenant_id , status : CourseStatus :: Idle , history : vec ! [] , metadata : CourseMetadata :: default () , title : None , summary : None , created_at : now , updated_at : now , } } # [doc = " Create a course with an initial title"] pub fn with_title (mut self , title : impl Into < String >) -> Self { self . title = Some (title . into ()) ; self } # [doc = " Commit a message to history (typically called when Shuttle completes)"] # [doc = " "] # [doc = " This is the ONLY way to add messages to the Course."] # [doc = " History is append-only and immutable once committed."] # [doc = " Also updates the cached total_history_tokens count."] pub fn commit_message (& mut self , message : CourseMessage) { if let Some (content) = & message . content { let tokens = estimate_tokens (content , TokenEstimationMethod :: Char4) ; self . metadata . total_history_tokens += tokens ; } self . history . push (message) ; self . updated_at = Timestamp :: now () ; if self . history . len () == 1 { self . status = CourseStatus :: Active ; } } # [doc = " Commit a user message (convenience method)"] pub fn commit_user_message (& mut self , content : impl Into < String >) -> UUID { let msg = CourseMessage :: user (self . id , content) ; let id = msg . id ; self . commit_message (msg) ; id } # [doc = " Commit a user message with shuttle tracking"] pub fn commit_user_message_with_shuttle (& mut self , shuttle_id : UUID , content : impl Into < String >) -> UUID { let msg = CourseMessage :: user_with_shuttle (self . id , shuttle_id , content) ; let id = msg . id ; self . commit_message (msg) ; id } # [doc = " Commit an assistant message (convenience method)"] pub fn commit_assistant_message (& mut self , content : impl Into < String > , agent : Option < String > ,) -> UUID { let msg = CourseMessage :: assistant (self . id , content , agent) ; let id = msg . id ; self . commit_message (msg) ; id } # [doc = " Commit an assistant message with shuttle tracking"] pub fn commit_assistant_message_with_shuttle (& mut self , shuttle_id : UUID , content : impl Into < String > , agent : Option < String > ,) -> UUID { let msg = CourseMessage :: assistant_with_shuttle (self . id , shuttle_id , content , agent) ; let id = msg . id ; self . commit_message (msg) ; id } # [doc = " Commit a system message (convenience method)"] pub fn commit_system_message (& mut self , content : impl Into < String >) -> UUID { let msg = CourseMessage :: system (self . id , content) ; let id = msg . id ; self . commit_message (msg) ; id } # [doc = " Mark course as active (being processed)"] pub fn set_active (& mut self) { self . status = CourseStatus :: Active ; self . updated_at = Timestamp :: now () ; } # [doc = " Mark course as idle (not being processed)"] pub fn set_idle (& mut self) { self . status = CourseStatus :: Idle ; self . updated_at = Timestamp :: now () ; } # [doc = " Archive the course"] pub fn archive (& mut self) { self . status = CourseStatus :: Archived ; self . updated_at = Timestamp :: now () ; } # [doc = " Get the last message in the history"] pub fn last_message (& self) -> Option < & CourseMessage > { self . history . last () } # [doc = " Get the message count"] pub fn message_count (& self) -> usize { self . history . len () } # [doc = " Check if course has any messages"] pub fn is_empty (& self) -> bool { self . history . is_empty () } # [doc = " Generate a preview/summary from the first message"] pub fn generate_preview (& self , max_length : usize) -> String { self . history . first () . and_then (| m | m . content . as_ref ()) . map (| c | { if c . len () > max_length { format ! ("{}..." , & c [.. max_length]) } else { c . clone () } }) . unwrap_or_else (| | "Empty course" . to_string ()) } # [doc = " Create a summary for list views"] pub fn to_summary (& self) -> CourseSummary { CourseSummary { id : self . id , preview : self . generate_preview (100) , message_count : self . message_count () , status : self . status . clone () , title : self . title . clone () , updated_at : self . updated_at , } } # [doc = " Get history for LLM context (as simple role/content pairs)"] # [doc = " "] # [doc = " DEPRECATED: Use `get_history_for_context_tokens()` for token-aware pruning."] pub fn get_history_for_context (& self , limit : usize) -> Vec < (String , String) > { self . history . iter () . rev () . take (limit) . rev () . filter_map (| m | { let role = match m . role { MessageRole :: User => "user" , MessageRole :: Assistant => "assistant" , MessageRole :: System => "system" , } ; m . content . as_ref () . map (| c | (role . to_string () , c . clone ())) }) . collect () } # [doc = " Get history for LLM context, pruned to fit within token budget"] # [doc = " "] # [doc = " This is the preferred method for building LLM context. It:"] # [doc = " 1. Iterates from most recent to oldest messages"] # [doc = " 2. Accumulates tokens until the budget is exceeded"] # [doc = " 3. Always includes at least `min_messages` for coherence"] # [doc = " 4. Returns messages in chronological order"] # [doc = " "] # [doc = " # Arguments"] # [doc = " * `config` - Course configuration with token limits"] # [doc = " "] # [doc = " # Returns"] # [doc = " Vec of (role, content) pairs, oldest first"] pub fn get_history_for_context_tokens (& self , config : & CourseConfig) -> Vec < (String , String) > { let max_tokens = config . available_tokens () ; let min_messages = config . min_messages ; let method = config . estimation_method ; let mut result = Vec :: new () ; let mut token_count = 0 ; let mut messages_included = 0 ; for msg in self . history . iter () . rev () { let role = match msg . role { MessageRole :: User => "user" , MessageRole :: Assistant => "assistant" , MessageRole :: System => "system" , } ; if let Some (content) = & msg . content { let msg_tokens = estimate_tokens (content , method) ; let should_include = messages_included < min_messages || token_count + msg_tokens <= max_tokens ; if should_include { token_count += msg_tokens ; messages_included += 1 ; result . push ((role . to_string () , content . clone ())) ; } else { break ; } } } result . reverse () ; result } # [doc = " Get history with detailed token information for debugging"] pub fn get_history_with_token_info (& self , config : & CourseConfig) -> ContextWindowInfo { let max_tokens = config . available_tokens () ; let method = config . estimation_method ; let mut messages = Vec :: new () ; let mut total_tokens = 0 ; for msg in & self . history { if let Some (content) = & msg . content { let tokens = estimate_tokens (content , method) ; total_tokens += tokens ; messages . push (MessageTokenInfo { id : msg . id , role : msg . role . clone () , tokens , included : total_tokens <= max_tokens , }) ; } } ContextWindowInfo { total_messages : self . history . len () , total_tokens , max_tokens , messages_included : messages . iter () . filter (| m | m . included) . count () , tokens_used : messages . iter () . filter (| m | m . included) . map (| m | m . tokens) . sum () , messages , } } # [doc = " Recalculate total_history_tokens from scratch"] # [doc = " "] # [doc = " Call this if you suspect the cached token count is out of sync,"] # [doc = " or after loading a Course from the database."] pub fn recalculate_token_count (& mut self) { self . metadata . total_history_tokens = self . history . iter () . filter_map (| m | m . content . as_ref ()) . map (| c | estimate_tokens (c , TokenEstimationMethod :: Char4)) . sum () ; } }

